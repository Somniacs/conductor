<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>conductor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>♭</text></svg>">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #0a0a1a;
            color: #e0e0e0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        .layout {
            display: flex;
            height: 100vh;
            height: 100dvh;
        }

        /* Sidebar */
        .sidebar {
            background: #10102a;
            border-right: 1px solid #1e1e3e;
            display: flex;
            flex-direction: column;
            overflow: visible;
            width: 210px;
            min-width: 210px;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px 16px 12px;
            border-bottom: 1px solid #1e1e3e;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-header h1 {
            font-size: 17px;
            font-weight: 600;
            color: #8080ff;
            letter-spacing: 0.5px;
        }

        .sidebar-actions {
            padding: 12px;
            border-bottom: 1px solid #1e1e3e;
            display: flex;
            gap: 6px;
        }

        .sidebar-actions button {
            flex: 1;
            padding: 7px 10px;
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            color: #c0c0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .sidebar-actions button:hover { background: #242450; }

        .server-status {
            display: none;
            padding: 8px 12px;
            background: #3a1a1a;
            border-bottom: 1px solid #5a2a2a;
            color: #ff6060;
            font-size: 11px;
            text-align: center;
        }
        .server-status.disconnected { display: block; }

        #session-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .session-item {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            transition: background 0.15s;
        }

        .session-item:hover { background: #1a1a3e; }
        .session-item.open { background: #151535; }
        .session-item.focused {
            background: #252560;
            padding-left: 10px;
            border-left: 2px solid #8080ee;
        }

        .session-name {
            font-weight: 400;
            overflow: hidden;
            min-width: 0;
            flex: 1;
        }

        .session-name > div:first-child {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .session-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .session-status.running { color: #44dd77; background: #113322; }
        .session-status.exited  { color: #ff6666; background: #331111; }
        .session-status.killed  { color: #ff9944; background: #332211; }

        .session-actions { display: flex; gap: 4px; margin-left: 6px; }
        .session-actions button {
            background: none; border: none; color: #666;
            cursor: pointer; font-size: 14px; padding: 2px 4px; border-radius: 3px;
        }
        .session-actions button:hover { color: #ff6666; background: #331111; }

        /* New session dialog */
        .new-session {
            padding: 12px;
            border-top: 1px solid #1e1e3e;
            display: none;
        }

        .new-session.open { display: block; }

        .new-session label {
            display: block;
            font-size: 11px;
            color: #808090;
            margin-bottom: 3px;
            margin-top: 8px;
        }

        .new-session label:first-child { margin-top: 0; }

        .new-session input, .new-session select {
            width: 100%;
            padding: 7px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
        }

        .new-session select option { background: #0a0a1a; }

        .new-session .run-btn {
            width: 100%;
            padding: 7px;
            margin-top: 10px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }

        .new-session .run-btn:hover { background: #3a3a7a; }

        /* Confirm dialog */
        .confirm-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .confirm-overlay.open { display: flex; }
        .confirm-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 20px 24px;
            min-width: 280px;
            max-width: 360px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .confirm-box p {
            margin: 0 0 16px;
            color: #d0d0e0;
            font-size: 14px;
            line-height: 1.4;
        }
        .confirm-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .confirm-actions button {
            padding: 6px 16px;
            border-radius: 5px;
            border: 1px solid #2a2a5a;
            cursor: pointer;
            font-size: 13px;
        }
        .confirm-cancel {
            background: transparent;
            color: #a0a0b0;
        }
        .confirm-cancel:hover { background: #1e1e3e; }
        .confirm-ok {
            background: #7a2a2a;
            border-color: #aa3a3a;
            color: #f0d0d0;
        }
        .confirm-ok:hover { background: #8a3a3a; }

        /* About modal */
        .about-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .about-overlay.open { display: flex; }
        .about-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 24px 28px;
            min-width: 300px;
            max-width: 420px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
        }
        .about-box h2 {
            font-size: 18px;
            color: #8080ff;
            margin: 0 0 4px;
            font-weight: 600;
        }
        .about-box .about-version {
            font-size: 11px;
            color: #606080;
            margin-bottom: 14px;
        }
        .about-box p {
            font-size: 13px;
            color: #b0b0c0;
            line-height: 1.5;
            margin: 0 0 12px;
        }
        .about-box a {
            color: #7070cc;
            text-decoration: none;
        }
        .about-box a:hover { text-decoration: underline; }
        .about-box .about-section {
            font-size: 11px;
            color: #606080;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 14px 0 6px;
        }
        .about-box ul {
            list-style: none;
            padding: 0;
            margin: 0 0 10px;
            font-size: 12px;
            color: #a0a0b0;
        }
        .about-box ul li { padding: 2px 0; }
        .about-close {
            position: absolute;
            top: 10px;
            right: 12px;
            background: none;
            border: none;
            color: #606080;
            font-size: 18px;
            cursor: pointer;
            padding: 2px 6px;
            line-height: 1;
        }
        .about-close:hover { color: #c0c0e0; }
        .menu-btn {
            background: none;
            border: none;
            color: #606080;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .menu-btn:hover { color: #a0a0d0; }

        /* Hamburger dropdown */
        .menu-wrapper { position: relative; }
        .menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            min-width: 140px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 400;
            overflow: hidden;
        }
        .menu-dropdown.open { display: block; }
        .menu-dropdown a {
            display: block;
            padding: 8px 14px;
            font-size: 13px;
            color: #c0c0e0;
            text-decoration: none;
            cursor: pointer;
        }
        .menu-dropdown a:hover { background: #1e1e4e; }
        .menu-dropdown .menu-sep {
            height: 1px;
            background: #2a2a5a;
            margin: 2px 0;
        }

        /* Directory picker */
        .dir-picker {
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            border-radius: 5px;
            margin-top: 2px;
            max-height: 200px;
            overflow-y: auto;
        }

        .dir-picker .dir-current {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid #1a1a3a;
            font-size: 12px;
            color: #8080ff;
            word-break: break-all;
        }

        .dir-picker .dir-current button {
            flex-shrink: 0;
            background: none;
            border: none;
            color: #808090;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .dir-picker .dir-current button:hover {
            background: #1a1a3e;
            color: #e0e0e0;
        }

        .dir-picker .dir-entry {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #c0c0e0;
        }

        .dir-picker .dir-entry:hover { background: #1a1a3e; }
        .dir-picker .dir-icon { color: #6060aa; font-size: 11px; }

        .dir-picker .dir-empty {
            padding: 8px 10px;
            font-size: 11px;
            color: #505070;
        }

        /* Content area */
        .content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-width: 0;
        }

        /* Split toolbar - only visible with 2+ panels */
        .toolbar {
            display: none;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            padding: 4px 12px;
            background: #10102a;
            border-bottom: 1px solid #1e1e3e;
            font-size: 12px;
            color: #808090;
            flex-shrink: 0;
        }

        .toolbar.visible { display: flex; }

        .toolbar button {
            padding: 3px 10px;
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            color: #a0a0c0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .toolbar button:hover { background: #242450; }
        .toolbar button.active { background: #2a2a6a; border-color: #4a4aaa; color: #e0e0e0; }

        /* Panels container */
        #panels {
            flex: 1;
            display: flex;
            overflow: hidden;
            background: #0a0a1a;
        }

        /* Split panes */
        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .split-container.vertical { flex-direction: column; }
        .split-container.horizontal { flex-direction: row; }

        .split-pane {
            flex: 1;
            overflow: hidden;
            display: flex;
            min-width: 100px;
            min-height: 80px;
        }

        .split-handle {
            flex-shrink: 0;
            background: #1e1e3e;
            transition: background 0.15s;
            position: relative;
        }

        .split-handle:hover, .split-handle.dragging {
            background: #4a4aaa;
        }

        .split-handle.h-handle {
            width: 5px;
            cursor: col-resize;
        }

        .split-handle.v-handle {
            height: 5px;
            cursor: row-resize;
        }

        /* Panel */
        .panel {
            display: flex;
            flex-direction: column;
            background: #12122a;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        .panel-header {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: #0e0e24;
            border-bottom: 1px solid #1e1e3e;
            font-size: 12px;
            min-height: 32px;
        }

        .panel-header .panel-title {
            flex: 1;
            text-align: center;
            font-weight: 500;
            color: #a0a0d0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .panel-focused .panel-header { background: #1a1a48; border-bottom: 1px solid #4040aa; }
        .panel-focused .panel-header .panel-title { color: #d0d0ff; }
        .panel-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-header button {
            background: none; border: none; color: #606080;
            cursor: pointer; font-size: 16px; padding: 4px 6px; line-height: 1;
        }
        .panel-header button:hover { color: #c0c0e0; }
        .panel-header button.close-btn:hover { color: #ff6666; }
        .panel-header .font-btn { font-size: 13px; font-weight: 600; }
        .panel-header .theme-btn { padding: 3px 6px; display: flex; align-items: center; }
        .theme-ring {
            display: inline-block;
            width: 12px; height: 12px;
            border-radius: 50%;
            border: 2px solid;
            box-sizing: border-box;
        }
        .theme-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 2px;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            min-width: 110px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 500;
            overflow: hidden;
        }
        .theme-menu.open { display: block; }
        .theme-menu a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            font-size: 12px;
            color: #c0c0e0;
            text-decoration: none;
            cursor: pointer;
        }
        .theme-menu a:hover { background: #1e1e4e; }
        .theme-menu a.active { color: #8080ff; }
        .theme-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .theme-menu a.active .theme-dot {
            outline: 2px solid;
            outline-offset: 1px;
        }

        .panel-terminal {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .terminal-wrapper {
            width: 100%;
            height: 100%;
            /* min-width is set dynamically from JS after measuring char width */
        }

        .panel-terminal pre {
            padding: 8px 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px; line-height: 1.4;
            white-space: pre-wrap; word-wrap: break-word;
            overflow-y: auto; height: 100%; color: #d0d0d0;
        }

        /* Thin scrollbars */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #2a2a5a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #3a3a7a; }
        /* Firefox */
        * { scrollbar-width: thin; scrollbar-color: #2a2a5a transparent; }

        /* Fallback input bar (only shown when xterm.js unavailable) */
        .panel-input {
            padding: 6px 8px;
            border-top: 1px solid #1e1e3e;
            background: #0e0e24;
        }

        .panel-input input {
            width: 100%;
            padding: 6px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            outline: none;
        }

        .panel-input input:focus { border-color: #4a4aaa; }

        /* Empty state */
        .empty-state {
            display: flex; align-items: center; justify-content: center;
            height: 100%; width: 100%;
            color: #404060; font-size: 14px;
            flex-direction: column; gap: 8px;
        }

        .empty-state .icon { font-size: 48px; opacity: 0.3; }

        /* Sidebar chevron toggle — sticks to sidebar edge */
        .drawer-toggle {
            position: absolute;
            top: 0;
            right: -16px;
            z-index: 301;
            background: #10102a;
            border: 1px solid #2a2a5a;
            border-left: none;
            color: #8080c0;
            font-size: 14px;
            width: 16px;
            height: 32px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        .drawer-toggle:hover { color: #c0c0e0; }

        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 299;
        }
        .sidebar-overlay.open { display: block; }

        /* Collapsible sidebar */
        .sidebar {
            position: relative;
            transition: width 0.2s ease, min-width 0.2s ease;
        }
        .layout.sidebar-collapsed .sidebar {
            width: 0;
            min-width: 0;
            border-right: none;
        }
        .layout.sidebar-collapsed .sidebar > *:not(.drawer-toggle) {
            display: none;
        }

        @media (max-width: 700px) {
            .sidebar {
                position: fixed;
                top: 0; left: 0; bottom: 0;
                width: 260px;
                min-width: 260px;
                z-index: 300;
                transform: translateX(-100%);
                transition: transform 0.2s ease;
            }
            .sidebar.open { transform: translateX(0); }
            .layout.sidebar-collapsed .sidebar {
                width: 260px;
                min-width: 260px;
                overflow: visible;
            }
            .drawer-toggle {
                left: 260px;
                right: auto;
                width: 20px;
                border-radius: 0 6px 6px 0;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="toggleDrawer()"></div>
    <div class="layout" id="layout">
        <aside class="sidebar" id="sidebar">
            <button class="drawer-toggle" id="drawer-toggle" onclick="toggleDrawer()">&#x2039;</button>
            <div class="sidebar-header">
                <h1><a href="https://github.com/xohm/conductor" target="_blank" style="color:inherit;text-decoration:none"><span style="font-size:1.8em;line-height:0;vertical-align:middle">♭</span> conductor</a></h1>
                <div class="menu-wrapper">
                    <button class="menu-btn" onclick="toggleMenu()" title="Menu">&#9776;</button>
                    <div class="menu-dropdown" id="hamburger-menu">
                        <a onclick="toggleMenu();toggleQR()">Link Device</a>
                        <div class="menu-sep"></div>
                        <a href="https://github.com/xohm/conductor/blob/master/README.md" target="_blank" onclick="toggleMenu()">Help</a>
                        <div class="menu-sep"></div>
                        <a onclick="toggleMenu();toggleAbout()">About</a>
                    </div>
                </div>
            </div>
            <div class="sidebar-actions">
                <button onclick="toggleNewSession()">+ New</button>
            </div>
            <div class="server-status" id="server-status">Server disconnected — retrying...</div>
            <div id="session-list"></div>
            <div class="new-session" id="new-session-dialog">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <span style="font-size:12px;font-weight:500;color:#a0a0d0;">New Session</span>
                    <button onclick="toggleNewSession()" style="background:none;border:none;color:#606080;cursor:pointer;font-size:16px;padding:0 2px;line-height:1;" title="Cancel">&times;</button>
                </div>
                <label>Session name</label>
                <input type="text" id="new-name" placeholder="e.g. research" autocomplete="off">
                <label>Command</label>
                <select id="new-command"></select>
                <label>Working directory</label>
                <div class="dir-picker" id="dir-picker"></div>
                <button class="run-btn" onclick="createSession()">Run</button>
            </div>
        </aside>
        <main class="content">
            <div class="toolbar" id="toolbar">
                <span>Split:</span>
                <button class="active" data-split="horizontal" onclick="setSplitDir('horizontal')">&#8596; Horizontal</button>
                <button data-split="vertical" onclick="setSplitDir('vertical')">&#8597; Vertical</button>
            </div>
            <div id="panels">
                <div class="empty-state">
                    <div class="icon">&#9837;</div>
                    <div>Select a session or create a new one</div>
                </div>
            </div>
        </main>
    </div>

    <div class="about-overlay" id="about-dialog" onclick="if(event.target===this)toggleAbout()">
        <div class="about-box">
            <button class="about-close" onclick="toggleAbout()">&times;</button>
            <h2><span style="font-size:1.4em;vertical-align:middle">♭</span> conductor</h2>
            <div class="about-version">v0.1.0</div>
            <p>Local orchestration layer for interactive terminal processes. Run sessions on your workstation, interact from anywhere.</p>
            <div class="about-section">Built with</div>
            <ul>
                <li><a href="https://fastapi.tiangolo.com" target="_blank">FastAPI</a> &mdash; async web framework</li>
                <li><a href="https://xtermjs.org" target="_blank">xterm.js</a> &mdash; terminal rendering</li>
                <li><a href="https://uvicorn.org" target="_blank">Uvicorn</a> &mdash; ASGI server</li>
                <li><a href="https://click.palletsprojects.com" target="_blank">Click</a> &mdash; CLI framework</li>
                <li><a href="https://tailscale.com" target="_blank">Tailscale</a> &mdash; secure remote access</li>
            </ul>
            <div class="about-section">Author</div>
            <p>Max Rheiner</p>
            <div class="about-section">Source</div>
            <p style="margin-bottom:0"><a href="https://github.com/xohm/conductor" target="_blank">github.com/xohm/conductor</a></p>
        </div>
    </div>

    <div class="about-overlay" id="qr-dialog" onclick="if(event.target===this)toggleQR()">
        <div class="about-box" style="text-align:center;min-width:260px;">
            <button class="about-close" onclick="toggleQR()">&times;</button>
            <h2 style="font-size:16px;margin-bottom:12px;">Link Device</h2>
            <div id="qr-content"></div>
        </div>
    </div>

    <div class="confirm-overlay" id="confirm-dialog">
        <div class="confirm-box">
            <p id="confirm-msg"></p>
            <div class="confirm-actions">
                <button class="confirm-cancel" id="confirm-no">Cancel</button>
                <button class="confirm-ok" id="confirm-yes">Stop</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
    <script>
        // --- State ---
        let sessions = [];
        let panels = [];
        let splitDir = 'horizontal';
        let allowedCommands = [];
        let selectedCwd = null;
        let focusedPanelId = null;
        const hasXterm = typeof Terminal !== 'undefined';

        // Terminal color scheme presets
        const THEMES = {
            default: {
                label: 'Default', dot: '#12122a',
                background: '#12122a', foreground: '#d0d0e0',
                cursor: '#8080ff', selectionBackground: '#3a3a7a',
                black: '#000000', red: '#ff5555', green: '#50fa7b', yellow: '#f1fa8c',
                blue: '#6272a4', magenta: '#ff79c6', cyan: '#8be9fd', white: '#f8f8f2',
            },
            dark: {
                label: 'Dark', dot: '#000000',
                background: '#000000', foreground: '#c0c0c0',
                cursor: '#ffffff', selectionBackground: '#333333',
                black: '#000000', red: '#cc0000', green: '#4e9a06', yellow: '#c4a000',
                blue: '#3465a4', magenta: '#75507b', cyan: '#06989a', white: '#d3d7cf',
            },
            mid: {
                label: 'Mid', dot: '#1e1e2e',
                background: '#1e1e2e', foreground: '#cdd6f4',
                cursor: '#f5e0dc', selectionBackground: '#45475a',
                black: '#45475a', red: '#f38ba8', green: '#a6e3a1', yellow: '#f9e2af',
                blue: '#89b4fa', magenta: '#f5c2e7', cyan: '#94e2d5', white: '#bac2de',
            },
            bright: {
                label: 'Bright', dot: '#fafafa',
                background: '#fafafa', foreground: '#383a42',
                cursor: '#526eff', selectionBackground: '#bfceff',
                black: '#383a42', red: '#e45649', green: '#50a14f', yellow: '#c18401',
                blue: '#4078f2', magenta: '#a626a4', cyan: '#0184bc', white: '#fafafa',
            },
            bernstein: {
                label: 'Bernstein', dot: '#ffb000',
                background: '#1a0e00', foreground: '#ffb000',
                cursor: '#ffb000', selectionBackground: '#4a2800',
                black: '#1a0e00', red: '#ffb000', green: '#ffb000', yellow: '#ffb000',
                blue: '#ffb000', magenta: '#ffb000', cyan: '#ffb000', white: '#ffb000',
                brightBlack: '#805800', brightRed: '#ffb000', brightGreen: '#ffb000', brightYellow: '#ffb000',
                brightBlue: '#ffb000', brightMagenta: '#ffb000', brightCyan: '#ffb000', brightWhite: '#ffb000',
            },
            green: {
                label: 'Green', dot: '#33ff00',
                background: '#001a00', foreground: '#33ff00',
                cursor: '#33ff00', selectionBackground: '#0a4400',
                black: '#001a00', red: '#33ff00', green: '#33ff00', yellow: '#33ff00',
                blue: '#33ff00', magenta: '#33ff00', cyan: '#33ff00', white: '#33ff00',
                brightBlack: '#1a8000', brightRed: '#33ff00', brightGreen: '#33ff00', brightYellow: '#33ff00',
                brightBlue: '#33ff00', brightMagenta: '#33ff00', brightCyan: '#33ff00', brightWhite: '#33ff00',
            },
        };
        const THEME_ORDER = ['default', 'dark', 'mid', 'bright', 'bernstein', 'green'];

        // Return a contrasting grey for the ring around a dot
        function contrastGrey(hex) {
            const c = hex.replace('#', '');
            const r = parseInt(c.substring(0, 2), 16);
            const g = parseInt(c.substring(2, 4), 16);
            const b = parseInt(c.substring(4, 6), 16);
            const lum = (r * 299 + g * 587 + b * 114) / 1000;
            return lum > 128 ? '#404040' : '#c0c0c0';
        }

        // Debounce helper
        function debounce(fn, ms) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => fn(...args), ms);
            };
        }

        // Debounced fit + resize per panel.
        // Batches rapid ResizeObserver / window resize events into one fit() call.
        const _panelFitters = {};
        function fitPanel(panel) {
            if (!_panelFitters[panel.id]) {
                _panelFitters[panel.id] = debounce((p) => {
                    if (!p.fitAddon || !p._termOpened) return;
                    try {
                        p.fitAddon.fit();
                    } catch (e) { return; }

                    // Enforce minimum columns — narrow panels get horizontal scroll instead of reflow
                    if (p.terminal.cols < MIN_COLS) {
                        p.terminal.resize(MIN_COLS, p.terminal.rows);
                    }

                    // Send actual applied dimensions to PTY
                    syncResizeToPTY(p);
                }, 100);
            }
            _panelFitters[panel.id](panel);
        }

        // --- Config ---
        async function fetchConfig() {
            try {
                const resp = await fetch('/config');
                const cfg = await resp.json();
                allowedCommands = cfg.allowed_commands || [];
                populateCommandSelect();
                browseTo('~');
            } catch (e) {}
        }

        function populateCommandSelect() {
            const sel = document.getElementById('new-command');
            sel.innerHTML = allowedCommands.map(c =>
                `<option value="${c.command}">${c.label}</option>`
            ).join('');
        }

        // --- Directory Browser ---
        async function browseTo(path) {
            try {
                const resp = await fetch(`/browse?path=${encodeURIComponent(path)}`);
                const data = await resp.json();
                selectedCwd = data.current;
                renderDirPicker(data);
            } catch (e) {}
        }

        function renderDirPicker(data) {
            const picker = document.getElementById('dir-picker');
            const shortPath = data.current.replace(/^\/home\/[^/]+/, '~');
            let html = `
                <div class="dir-current">
                    ${data.parent ? `<button onclick="browseTo('${data.parent}')" title="Go up">&#8592;</button>` : ''}
                    <span>${shortPath}</span>
                </div>
            `;
            if (data.directories.length === 0) {
                html += '<div class="dir-empty">No subdirectories</div>';
            } else {
                html += data.directories.map(d =>
                    `<div class="dir-entry" onclick="browseTo('${d.path}')">
                        <span class="dir-icon">&#128193;</span>
                        <span>${d.name}</span>
                    </div>`
                ).join('');
            }
            picker.innerHTML = html;
        }

        // --- Server Status ---
        function setServerStatus(connected) {
            const el = document.getElementById('server-status');
            if (connected) {
                el.classList.remove('disconnected');
            } else {
                el.classList.add('disconnected');
            }
        }

        // --- Session List ---
        async function fetchSessions() {
            try {
                const resp = await fetch('/sessions');
                sessions = await resp.json();
                setServerStatus(true);
                renderSessionList();
            } catch (e) {
                setServerStatus(false);
            }
        }

        function getCommandLabel(command) {
            const match = allowedCommands.find(c => c.command === command);
            return match ? match.label : command.split(/\s/)[0];
        }

        function renderSessionList() {
            const list = document.getElementById('session-list');
            if (sessions.length === 0) {
                list.innerHTML = '<div style="padding:12px;color:#404060;font-size:13px;">No sessions</div>';
                return;
            }
            list.innerHTML = sessions.map(s => {
                const isOpen = panels.some(p => p.id === s.id);
                const isFocused = focusedPanelId === s.id;
                const appLabel = getCommandLabel(s.command);
                return `
                    <div class="session-item ${isFocused ? 'focused' : isOpen ? 'open' : ''}" onclick="focusSession('${s.id}', '${s.name}')">
                        <div class="session-name">
                            <div>${s.name}</div>
                            <div style="font-size:10px;color:#606080;font-weight:400;">${appLabel}</div>
                        </div>
                        <div style="display:flex;align-items:center;gap:4px;">
                            <span class="session-status ${s.status}">${s.status}</span>
                            <div class="session-actions">
                                <button onclick="event.stopPropagation();killSession('${s.id}')" title="Stop">&times;</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // --- Panels ---
        function setFocus(id) {
            if (focusedPanelId === id) return;
            focusedPanelId = id;
            // Update panel visual focus
            panels.forEach(p => {
                if (p.element) p.element.classList.toggle('panel-focused', p.id === id);
            });
            renderSessionList();
        }

        function focusSession(id, name) {
            closeDrawer();
            const existing = panels.find(p => p.id === id);
            if (existing) {
                setFocus(id);
                if (existing.terminal) existing.terminal.focus();
                return;
            }
            openSession(id, name);
        }

        function openSession(id, name) {
            if (panels.find(p => p.id === id)) return;

            const panel = { id, name, ws: null, terminal: null, fitAddon: null, element: null, _resizeObserver: null, _theme: 'default' };
            panels.push(panel);
            buildPanelElement(panel);
            layoutPanels();
            setFocus(id);
        }

        function updateToolbar() {
            const toolbar = document.getElementById('toolbar');
            toolbar.classList.toggle('visible', panels.length >= 2);
        }

        const MIN_COLS = 80;

        // Build the panel DOM + terminal ONCE. This is only called when a session is first opened.
        function buildPanelElement(panel) {
            const div = document.createElement('div');
            div.className = 'panel';

            const termEl = document.createElement('div');
            termEl.className = 'panel-terminal';

            // Wrapper enforces min-width so the terminal never shrinks below MIN_COLS.
            // When the panel is narrower, .panel-terminal scrolls horizontally.
            const termWrapper = document.createElement('div');
            termWrapper.className = 'terminal-wrapper';
            termEl.appendChild(termWrapper);

            div.innerHTML = `
                <div class="panel-header">
                    <span class="panel-title">${panel.name}</span>
                    <div class="panel-header-actions" style="position:relative;">
                        <button class="theme-btn" id="theme-btn-${panel.id}" onclick="toggleThemeMenu('${panel.id}')" title="Color scheme"><span class="theme-ring" style="background:${THEMES['default'].dot};border-color:${contrastGrey(THEMES['default'].dot)}"></span></button>
                        <div class="theme-menu" id="theme-menu-${panel.id}">
                            ${THEME_ORDER.map(k => `<a onclick="event.stopPropagation();setTheme('${panel.id}','${k}')" data-theme="${k}" data-cursor="${THEMES[k].cursor}"><span class="theme-dot" style="background:${THEMES[k].dot};border-color:${contrastGrey(THEMES[k].dot)}"></span>${THEMES[k].label}</a>`).join('')}
                        </div>
                        <button class="font-btn" onclick="changeFontSize('${panel.id}', -1)" title="Smaller">&#8722;</button>
                        <button class="font-btn" onclick="changeFontSize('${panel.id}', 1)" title="Bigger">+</button>
                        <button class="close-btn" onclick="closePanel('${panel.id}')">&times;</button>
                    </div>
                </div>
            `;
            div.appendChild(termEl);

            panel.element = div;
            panel._termEl = termEl;
            panel._termWrapper = termWrapper;

            if (hasXterm) {
                const defT = THEMES['default'];
                const term = new Terminal({
                    cursorBlink: true,
                    fontSize: window.innerWidth <= 700 ? 8 : 14,
                    fontFamily: "'Consolas', 'Monaco', 'Courier New', monospace",
                    theme: {
                        background: defT.background, foreground: defT.foreground,
                        cursor: defT.cursor, selectionBackground: defT.selectionBackground,
                        black: defT.black, red: defT.red, green: defT.green, yellow: defT.yellow,
                        blue: defT.blue, magenta: defT.magenta, cyan: defT.cyan, white: defT.white,
                        brightBlack: defT.brightBlack, brightRed: defT.brightRed,
                        brightGreen: defT.brightGreen, brightYellow: defT.brightYellow,
                        brightBlue: defT.brightBlue, brightMagenta: defT.brightMagenta,
                        brightCyan: defT.brightCyan, brightWhite: defT.brightWhite,
                    },
                    scrollback: 5000,
                    convertEol: false,
                });

                panel.terminal = term;

                if (typeof FitAddon !== 'undefined') {
                    const fitAddon = new FitAddon.FitAddon();
                    term.loadAddon(fitAddon);
                    panel.fitAddon = fitAddon;
                }

                term.onData((data) => {
                    if (panel.ws && panel.ws.readyState === WebSocket.OPEN) {
                        panel.ws.send(data);
                    }
                });
            }

            // Clicking anywhere on the panel sets focus
            div.addEventListener('mousedown', () => setFocus(panel.id));
            div.addEventListener('touchstart', () => setFocus(panel.id), { passive: true });
        }

        // Ensure the xterm terminal is opened into its container and sized correctly.
        // Safe to call multiple times — only opens once.
        function ensureTerminalOpen(panel) {
            if (!panel.terminal || !panel._termEl) return;
            if (panel._termOpened) {
                // Already open — just refit
                fitPanel(panel);
                return;
            }

            // Open into the wrapper (which has min-width for horizontal scroll)
            const target = panel._termWrapper || panel._termEl;
            panel.terminal.open(target);
            panel._termOpened = true;

            if (panel.fitAddon) {
                panel.fitAddon.fit();

                // Measure actual char width and set wrapper min-width so terminal never shrinks below MIN_COLS
                if (panel.terminal.cols > 0 && target.clientWidth > 0) {
                    const charWidth = target.clientWidth / panel.terminal.cols;
                    target.style.minWidth = Math.ceil(MIN_COLS * charWidth) + 'px';
                }

                // Send resize to PTY so the app redraws at the correct size,
                // then connect WebSocket — buffer replay will arrive after redraw.
                syncResizeToPTY(panel);
                setTimeout(() => {
                    if (!panel.ws) connectWebSocket(panel);
                }, 150);

                // Watch the scroll container (not the wrapper) for size changes
                if (typeof ResizeObserver !== 'undefined') {
                    panel._resizeObserver = new ResizeObserver(() => fitPanel(panel));
                    panel._resizeObserver.observe(panel._termEl);
                }
            }
        }

        // Rearrange existing panel elements into the layout WITHOUT destroying terminals.
        function layoutPanels() {
            const container = document.getElementById('panels');

            // Detach all children without destroying them
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            updateToolbar();

            if (panels.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">&#9837;</div>
                        <div>Select a session or create a new one</div>
                    </div>`;
                renderSessionList();
                return;
            }

            if (panels.length === 1) {
                const pane = document.createElement('div');
                pane.className = 'split-pane';
                pane.style.flex = '1';
                pane.appendChild(panels[0].element);
                container.appendChild(pane);
            } else {
                const wrapper = document.createElement('div');
                wrapper.className = `split-container ${splitDir}`;

                panels.forEach((panel, i) => {
                    if (i > 0) {
                        const prevPane = wrapper.lastElementChild;
                        const handle = document.createElement('div');
                        handle.className = `split-handle ${splitDir === 'horizontal' ? 'h-handle' : 'v-handle'}`;
                        initDragHandle(handle, prevPane, splitDir);
                        wrapper.appendChild(handle);
                    }

                    const pane = document.createElement('div');
                    pane.className = 'split-pane';
                    pane.style.flex = '1';
                    pane.appendChild(panel.element);
                    wrapper.appendChild(pane);
                });

                container.appendChild(wrapper);
            }

            renderSessionList();

            // Open terminals that haven't been opened yet + refit all
            requestAnimationFrame(() => {
                panels.forEach(p => ensureTerminalOpen(p));
            });
        }

        function changeFontSize(id, delta) {
            const panel = panels.find(p => p.id === id);
            if (!panel || !panel.terminal) return;
            const current = panel.terminal.options.fontSize || 14;
            const next = Math.min(28, Math.max(3, current + delta));
            panel.terminal.options.fontSize = next;
            // Recalculate wrapper min-width for new char size
            const target = panel._termWrapper || panel._termEl;
            if (panel.fitAddon) {
                panel.fitAddon.fit();
                if (panel.terminal.cols > 0 && target.clientWidth > 0) {
                    const charWidth = target.clientWidth / panel.terminal.cols;
                    target.style.minWidth = Math.ceil(MIN_COLS * charWidth) + 'px';
                }
                if (panel.terminal.cols < MIN_COLS) {
                    panel.terminal.resize(MIN_COLS, panel.terminal.rows);
                }
                syncResizeToPTY(panel);
            }
        }

        function toggleThemeMenu(id) {
            const menu = document.getElementById(`theme-menu-${id}`);
            // Close all other theme menus first
            document.querySelectorAll('.theme-menu.open').forEach(m => {
                if (m !== menu) m.classList.remove('open');
            });
            menu.classList.toggle('open');
            // Mark active theme
            const panel = panels.find(p => p.id === id);
            const current = panel?._theme || 'default';
            menu.querySelectorAll('a').forEach(a => {
                const isActive = a.dataset.theme === current;
                a.classList.toggle('active', isActive);
                const dot = a.querySelector('.theme-dot');
                if (dot) dot.style.outlineColor = isActive ? '#a0a0a0' : 'transparent';
            });
        }

        function setTheme(id, themeKey) {
            const panel = panels.find(p => p.id === id);
            if (!panel || !panel.terminal) return;
            const t = THEMES[themeKey];
            if (!t) return;
            panel._theme = themeKey;
            const themeObj = {
                background: t.background, foreground: t.foreground,
                cursor: t.cursor, selectionBackground: t.selectionBackground,
                black: t.black, red: t.red, green: t.green, yellow: t.yellow,
                blue: t.blue, magenta: t.magenta, cyan: t.cyan, white: t.white,
            };
            if (t.brightBlack) {
                themeObj.brightBlack = t.brightBlack; themeObj.brightRed = t.brightRed;
                themeObj.brightGreen = t.brightGreen; themeObj.brightYellow = t.brightYellow;
                themeObj.brightBlue = t.brightBlue; themeObj.brightMagenta = t.brightMagenta;
                themeObj.brightCyan = t.brightCyan; themeObj.brightWhite = t.brightWhite;
            }
            panel.terminal.options.theme = themeObj;
            // Also update the panel background to match
            panel.element.style.background = t.background;
            // Update the theme button ring to reflect active theme
            const btn = document.getElementById(`theme-btn-${id}`);
            if (btn) {
                const ring = btn.querySelector('.theme-ring');
                if (ring) {
                    ring.style.background = t.dot;
                    ring.style.borderColor = contrastGrey(t.dot);
                }
            }
            // Update active markers in the menu
            const menu = document.getElementById(`theme-menu-${id}`);
            if (menu) {
                menu.querySelectorAll('a').forEach(a => {
                    const isActive = a.dataset.theme === themeKey;
                    a.classList.toggle('active', isActive);
                    const dot = a.querySelector('.theme-dot');
                    if (dot) dot.style.outlineColor = isActive ? '#a0a0a0' : 'transparent';
                });
                menu.classList.remove('open');
            }
        }

        // Close theme menus when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.theme-menu') && !e.target.closest('.theme-btn')) {
                document.querySelectorAll('.theme-menu.open').forEach(m => m.classList.remove('open'));
            }
        });

        function closePanel(id) {
            const idx = panels.findIndex(p => p.id === id);
            if (idx < 0) return;
            const panel = panels[idx];
            if (panel._resizeObserver) { panel._resizeObserver.disconnect(); panel._resizeObserver = null; }
            if (panel.ws) { panel.ws.close(); panel.ws = null; }
            if (panel.terminal) { panel.terminal.dispose(); }
            delete _panelFitters[panel.id];
            panels.splice(idx, 1);
            // Move focus to next remaining panel
            if (focusedPanelId === id) {
                focusedPanelId = panels.length > 0 ? panels[0].id : null;
            }
            layoutPanels();
            if (panels.length === 0) openDrawer();
        }

        // --- Drag handle for resizable splits ---
        function initDragHandle(handle, pane, direction) {
            let startPos, startSize;

            function onStart(clientX, clientY) {
                handle.classList.add('dragging');
                startPos = direction === 'horizontal' ? clientX : clientY;
                startSize = direction === 'horizontal' ? pane.offsetWidth : pane.offsetHeight;
                document.body.style.cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';
                document.body.style.userSelect = 'none';
            }

            function onMove(clientX, clientY) {
                const currentPos = direction === 'horizontal' ? clientX : clientY;
                const delta = currentPos - startPos;
                const newSize = Math.max(80, startSize + delta);
                pane.style.flex = 'none';
                if (direction === 'horizontal') {
                    pane.style.width = newSize + 'px';
                } else {
                    pane.style.height = newSize + 'px';
                }
                // ResizeObserver on each terminal container handles fit + server resize
            }

            function onEnd() {
                handle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }

            // Mouse
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                onStart(e.clientX, e.clientY);
                function mm(e) { onMove(e.clientX, e.clientY); }
                function mu() {
                    onEnd();
                    document.removeEventListener('mousemove', mm);
                    document.removeEventListener('mouseup', mu);
                }
                document.addEventListener('mousemove', mm);
                document.addEventListener('mouseup', mu);
            });

            // Touch
            handle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                onStart(t.clientX, t.clientY);
                function tm(e) { const t = e.touches[0]; onMove(t.clientX, t.clientY); }
                function te() {
                    onEnd();
                    document.removeEventListener('touchmove', tm);
                    document.removeEventListener('touchend', te);
                }
                document.addEventListener('touchmove', tm, { passive: false });
                document.addEventListener('touchend', te);
            }, { passive: false });
        }

        // Send current terminal size to PTY via REST
        function syncResizeToPTY(panel) {
            if (!panel.terminal) return;
            const cols = panel.terminal.cols;
            const rows = panel.terminal.rows;
            if (cols > 0 && rows > 0) {
                fetch(`/sessions/${panel.id}/resize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rows, cols }),
                });
            }
        }

        // --- WebSocket ---
        function connectWebSocket(panel) {
            const isReconnect = !!panel.ws;
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const ws = new WebSocket(`${protocol}//${location.host}/sessions/${panel.id}/stream`);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                setServerStatus(true);
                // On reconnect, clear terminal to prevent duplicate content from buffer replay
                if (isReconnect && panel.terminal) {
                    panel.terminal.reset();
                }
                panel._bufferReplay = true;
                setTimeout(() => {
                    syncResizeToPTY(panel);
                    panel._bufferReplay = false;
                }, 1500);
            };

            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer && event.data.byteLength === 0) return;
                if (!panel._bufferReplay) trackActivity(panel);
                if (panel.terminal) {
                    const data = event.data instanceof ArrayBuffer
                        ? new Uint8Array(event.data) : event.data;
                    panel.terminal.write(data);
                } else {
                    const termDiv = document.getElementById(`term-${panel.id}`);
                    const pre = termDiv && termDiv.querySelector('pre');
                    if (pre) {
                        const text = event.data instanceof ArrayBuffer
                            ? new TextDecoder().decode(event.data) : event.data;
                        pre.textContent += text;
                        pre.scrollTop = pre.scrollHeight;
                    }
                }
            };

            ws.onclose = () => {
                setTimeout(() => {
                    if (panels.find(p => p.id === panel.id)) {
                        connectWebSocket(panel);
                    }
                }, 2000);
            };

            ws.onerror = () => {
                setServerStatus(false);
            };

            panel.ws = ws;
        }

        // --- Input (fallback only) ---
        function handlePanelInput(event, id) {
            if (event.key !== 'Enter') return;
            const input = event.target;
            const panel = panels.find(p => p.id === id);
            if (panel && panel.ws && panel.ws.readyState === WebSocket.OPEN) {
                panel.ws.send(input.value + '\n');
                input.value = '';
            }
        }

        // --- Split Direction ---
        function setSplitDir(dir) {
            splitDir = dir;
            document.querySelectorAll('.toolbar button[data-split]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.split === dir);
            });
            if (panels.length >= 2) {
                layoutPanels();
            }
        }

        // --- New Session ---
        function toggleDrawer() {
            const layout = document.getElementById('layout');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            const isMobile = window.innerWidth <= 700;

            if (isMobile) {
                sidebar.classList.toggle('open');
                document.getElementById('sidebar-overlay').classList.toggle('open');
            } else {
                layout.classList.toggle('sidebar-collapsed');
            }

            // Update chevron direction and position
            const collapsed = layout.classList.contains('sidebar-collapsed');
            const mobileOpen = sidebar.classList.contains('open');
            const isOpen = (!isMobile && !collapsed) || (isMobile && mobileOpen);
            toggle.innerHTML = isOpen ? '&#x2039;' : '&#x203a;';
            toggle.classList.toggle('collapsed', !isOpen);

            // Refit terminals after sidebar transition
            setTimeout(() => panels.forEach(p => fitPanel(p)), 250);
        }

        function closeDrawer() {
            if (window.innerWidth > 700) return;
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            sidebar.classList.remove('open');
            document.getElementById('sidebar-overlay').classList.remove('open');
            toggle.innerHTML = '&#x203a;';
            toggle.classList.add('collapsed');
        }

        function openDrawer() {
            const layout = document.getElementById('layout');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            if (window.innerWidth <= 700) {
                sidebar.classList.add('open');
                document.getElementById('sidebar-overlay').classList.add('open');
            } else {
                layout.classList.remove('sidebar-collapsed');
            }
            toggle.innerHTML = '&#x2039;';
            toggle.classList.remove('collapsed');
        }

        function toggleMenu() {
            document.getElementById('hamburger-menu').classList.toggle('open');
        }

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('hamburger-menu');
            if (menu.classList.contains('open') && !e.target.closest('.menu-wrapper')) {
                menu.classList.remove('open');
            }
        });

        function toggleAbout() {
            document.getElementById('about-dialog').classList.toggle('open');
        }

        function isLocalhost() {
            const h = location.hostname;
            return h === 'localhost' || h === '127.0.0.1' || h === '::1' || h === '0.0.0.0';
        }

        function toggleQR() {
            const dialog = document.getElementById('qr-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                const container = document.getElementById('qr-content');
                if (isLocalhost()) {
                    container.innerHTML = `
                        <div style="padding:16px 8px;">
                            <div style="font-size:28px;margin-bottom:10px;">&#9888;</div>
                            <p style="font-size:13px;color:#ff9944;margin:0 0 8px;">You are on localhost</p>
                            <p style="font-size:12px;color:#808090;margin:0;line-height:1.5;">
                                Other devices cannot reach this address.<br>
                                Connect via your Tailscale IP or network IP to generate a QR code.
                            </p>
                        </div>`;
                } else {
                    const url = window.location.href;
                    container.innerHTML = `
                        <p style="font-size:12px;color:#808090;margin-bottom:14px;">Scan to open on another device</p>
                        <canvas id="qr-canvas" style="margin:0 auto 12px;display:block;border-radius:6px;"></canvas>
                        <p style="font-size:11px;color:#606080;word-break:break-all;margin:0;"></p>`;
                    container.querySelector('p:last-child').textContent = url;
                    try {
                        const qr = qrcode(0, 'M');
                        qr.addData(url);
                        qr.make();
                        const count = qr.getModuleCount();
                        const scale = 6;
                        const margin = 4;
                        const size = count * scale + margin * 2 * scale;
                        const canvas = document.getElementById('qr-canvas');
                        canvas.width = size;
                        canvas.height = size;
                        canvas.style.width = '200px';
                        canvas.style.height = '200px';
                        canvas.style.imageRendering = 'pixelated';
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, size, size);
                        ctx.fillStyle = '#000000';
                        for (let r = 0; r < count; r++) {
                            for (let c = 0; c < count; c++) {
                                if (qr.isDark(r, c)) {
                                    ctx.fillRect((c + margin) * scale, (r + margin) * scale, scale, scale);
                                }
                            }
                        }
                    } catch (e) {
                        document.getElementById('qr-canvas').parentElement.innerHTML = '<p style="color:#ff6666;font-size:12px;">Failed to generate QR code</p>';
                    }
                }
            }
        }

        function toggleNewSession() {
            const dialog = document.getElementById('new-session-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                document.getElementById('new-name').focus();
            }
        }

        async function createSession() {
            const name = document.getElementById('new-name').value.trim();
            const command = document.getElementById('new-command').value;
            const cwd = selectedCwd || null;
            if (!name || !command) return;

            try {
                const resp = await fetch('/sessions/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, command, cwd }),
                });
                if (resp.ok) {
                    document.getElementById('new-name').value = '';
                    document.getElementById('new-session-dialog').classList.remove('open');
                    await fetchSessions();
                    openSession(name, name);
                } else {
                    const err = await resp.json();
                    alert(err.detail || 'Failed to create session');
                }
            } catch (e) {
                alert('Server unreachable');
            }
        }

        function showConfirm(message) {
            return new Promise(resolve => {
                const overlay = document.getElementById('confirm-dialog');
                document.getElementById('confirm-msg').textContent = message;
                overlay.classList.add('open');
                const yes = document.getElementById('confirm-yes');
                const no = document.getElementById('confirm-no');
                function cleanup(result) {
                    overlay.classList.remove('open');
                    yes.replaceWith(yes.cloneNode(true));
                    no.replaceWith(no.cloneNode(true));
                    resolve(result);
                }
                yes.addEventListener('click', () => cleanup(true), { once: true });
                no.addEventListener('click', () => cleanup(false), { once: true });
                overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(false); }, { once: true });
            });
        }

        async function killSession(id) {
            const session = sessions.find(s => s.id === id);
            const label = session ? session.name : 'this session';
            if (!await showConfirm(`Stop "${label}"? This will terminate the process.`)) return;
            try {
                await fetch(`/sessions/${id}`, { method: 'DELETE' });
                closePanel(id);
                await fetchSessions();
            } catch (e) {}
        }

        // --- Window resize fallback ---
        window.addEventListener('resize', debounce(() => {
            panels.forEach(p => fitPanel(p));
        }, 150));

        // --- Notifications ---
        // Detect when a session needs attention by scanning terminal output.
        // Two triggers: (1) permission/question prompts, (2) long idle after sustained activity.
        let notificationsEnabled = false;

        async function requestNotificationPermission() {
            if (!('Notification' in window)) return false;
            if (Notification.permission === 'granted') return true;
            if (Notification.permission === 'denied') return false;
            const result = await Notification.requestPermission();
            return result === 'granted';
        }

        function sendNotification(title, body) {
            if (!notificationsEnabled) return;
            if (document.visibilityState === 'visible') return;
            try {
                new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="80" font-size="80">♭</text></svg>',
                    tag: 'conductor-' + title,
                });
            } catch (e) {}
        }

        // Read the last N non-empty lines from the xterm buffer
        function getTerminalTail(panel, count) {
            if (!panel.terminal) return '';
            const buf = panel.terminal.buffer.active;
            const lines = [];
            for (let i = buf.length - 1; i >= 0 && lines.length < count; i--) {
                const line = buf.getLine(i);
                if (line) {
                    const text = line.translateToString(true).trim();
                    if (text) lines.unshift(text);
                }
            }
            return lines.join('\n');
        }

        const _activityTimers = {};
        const _outputBytes = {};     // track output volume per panel
        const _lastNotified = {};    // prevent duplicate notifications
        function trackActivity(panel) {
            if (_activityTimers[panel.id]) clearTimeout(_activityTimers[panel.id]);

            // Count output chunks — we only notify after sustained activity
            _outputBytes[panel.id] = (_outputBytes[panel.id] || 0) + 1;

            _activityTimers[panel.id] = setTimeout(() => {
                // Need real output before we consider notifying
                const volume = _outputBytes[panel.id] || 0;
                _outputBytes[panel.id] = 0;
                if (volume < 10) return; // ignore tiny bursts (keepalives, cursor moves)

                const tail = getTerminalTail(panel, 8);
                if (!tail) return;

                let reason = null;
                // Permission / confirmation prompts
                if (/\(y\)es.*\(n\)o/i.test(tail) || /\[Y\/n\]/i.test(tail) || /\(y\/n\)/i.test(tail)) {
                    reason = 'Needs confirmation';
                } else if (/allow|deny|approve|reject/i.test(tail) && /\?/m.test(tail)) {
                    reason = 'Asking for permission';
                // Question being asked
                } else if (/\?\s*$/m.test(tail)) {
                    reason = 'Asking a question';
                // Long idle after lots of output = task likely finished
                } else if (volume > 100) {
                    reason = 'Task may be complete';
                }

                if (!reason) return;
                // Don't re-notify the same thing
                const key = panel.id + ':' + reason;
                if (_lastNotified[key]) return;
                _lastNotified[key] = true;
                // Clear after 60s so we can notify again for a new occurrence
                setTimeout(() => { delete _lastNotified[key]; }, 60000);

                sendNotification(`♭ ${panel.name}`, reason);
            }, 5000); // 5s of silence before checking
        }

        // --- Init ---
        // On mobile, open the sidebar drawer on load
        if (window.innerWidth <= 700) {
            document.getElementById('sidebar').classList.add('open');
        }

        // Request notification permission on first user interaction
        document.addEventListener('click', async function initNotif() {
            notificationsEnabled = await requestNotificationPermission();
            document.removeEventListener('click', initNotif);
        }, { once: true });

        fetchConfig();
        fetchSessions();
        setInterval(fetchSessions, 3000);
    </script>
</body>
</html>
