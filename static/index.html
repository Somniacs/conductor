<!--
  conductor — Local orchestration for terminal sessions.

  Copyright (c) 2026 Max Rheiner / Somniacs AG

  Licensed under the MIT License. You may obtain a copy
  of the license at:

      https://opensource.org/licenses/MIT

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND.

  Dashboard — single-file web UI with multi-server support,
  split-pane xterm.js terminals, and QR-based server pairing.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-visual">
    <title>conductor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>♭</text></svg>">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden;
            overscroll-behavior: none;
        }
        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #0a0a1a;
            color: #e0e0e0;
        }

        .layout {
            display: flex;
            height: 100%;
        }

        /* Sidebar */
        .sidebar {
            background: #10102a;
            border-right: 1px solid #1e1e3e;
            display: flex;
            flex-direction: column;
            overflow: visible;
            width: 210px;
            min-width: 210px;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px 16px 12px;
            border-bottom: 1px solid #1e1e3e;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .sidebar-header h1 {
            font-size: 17px;
            font-weight: 600;
            color: #8080ff;
            letter-spacing: 0.5px;
        }

        .sidebar-actions {
            padding: 12px;
            border-bottom: 1px solid #1e1e3e;
            display: flex;
            gap: 6px;
        }

        .sidebar-actions button {
            flex: 1;
            padding: 7px 10px;
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            color: #c0c0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .sidebar-actions button:hover { background: #242450; }

        .server-status {
            display: none;
            padding: 8px 12px;
            background: #3a1a1a;
            border-bottom: 1px solid #5a2a2a;
            color: #ff6060;
            font-size: 11px;
            text-align: center;
        }
        .server-status.disconnected { display: block; }

        @keyframes spin { to { transform: rotate(360deg); } }
        .server-status .spinner {
            display: inline-block;
            width: 9px; height: 9px;
            border: 1.5px solid #ff606040;
            border-top-color: #ff6060;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 6px;
        }

        .update-status {
            display: none;
            padding: 8px 12px;
            background: #1a2a3a;
            border-top: 1px solid #2a3a5a;
            color: #60b0ff;
            font-size: 11px;
            text-align: center;
            text-decoration: none;
            cursor: pointer;
        }
        .update-status:hover { background: #1e3040; }

        #session-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .session-item {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            transition: background 0.15s;
        }

        .session-item:hover { background: #1a1a3e; }
        .session-item.open {
            background: #151535;
            padding-left: 10px;
            border-left: 2px solid #404080;
        }
        .session-item.focused {
            background: #252560;
            padding-left: 10px;
            border-left: 2px solid #8080ee;
        }

        .session-name {
            font-weight: 400;
            overflow: hidden;
            min-width: 0;
            flex: 1;
        }

        .session-name > div:first-child {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .session-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .session-status.running  { color: #44dd77; background: #113322; }
        .session-status.stopping { color: #ffcc44; background: #332b11; }
        .session-status.resuming { color: #44dd77; background: #113322; }

        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner {
            display: inline-block;
            width: 10px; height: 10px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.7s linear infinite;
            vertical-align: middle;
            margin-right: 3px;
        }
        .session-status.exited   { color: #ff6666; background: #331111; }
        .session-status.killed   { color: #ff9944; background: #332211; }

        .session-actions { display: flex; gap: 4px; margin-left: 6px; }
        .session-actions button {
            background: none; border: none; color: #666;
            cursor: pointer; font-size: 14px; padding: 2px 4px; border-radius: 3px;
        }
        .session-actions button:hover { color: #ff6666; background: #331111; }

        /* Server group headers in sidebar */
        .server-group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px 4px;
            font-size: 11px;
            color: #7878a0;
            letter-spacing: 0.3px;
        }
        .server-group-header:first-child { padding-top: 4px; }
        .server-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .server-dot.connected { background: #44dd77; }
        .server-dot.disconnected { background: #ff4444; }

        /* New session dialog */
        .new-session {
            padding: 12px;
            border-top: 1px solid #1e1e3e;
            display: none;
        }

        .new-session.open { display: block; }

        .new-session label {
            display: block;
            font-size: 11px;
            color: #9898b0;
            margin-bottom: 3px;
            margin-top: 8px;
        }

        .new-session label:first-child { margin-top: 0; }

        .new-session input, .new-session select {
            width: 100%;
            padding: 7px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
        }

        .new-session select option { background: #0a0a1a; }

        .new-session .run-btn {
            width: 100%;
            padding: 7px;
            margin-top: 10px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }

        .new-session .run-btn:disabled { background: #1a1a3a; border-color: #2a2a4a; color: #505070; cursor: not-allowed; }
        .new-session .run-btn:hover:not(:disabled) { background: #3a3a7a; }

        /* Confirm dialog */
        .confirm-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .confirm-overlay.open { display: flex; }
        .confirm-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 20px 24px;
            min-width: 280px;
            max-width: 360px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .confirm-box p {
            margin: 0 0 16px;
            color: #d0d0e0;
            font-size: 14px;
            line-height: 1.4;
        }
        .confirm-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .confirm-actions button {
            padding: 6px 16px;
            border-radius: 5px;
            border: 1px solid #2a2a5a;
            cursor: pointer;
            font-size: 13px;
        }
        .confirm-cancel {
            background: transparent;
            color: #b0b0c8;
        }
        .confirm-cancel:hover { background: #1e1e3e; }
        .confirm-ok {
            background: #7a2a2a;
            border-color: #aa3a3a;
            color: #f0d0d0;
        }
        .confirm-ok:hover { background: #8a3a3a; }

        /* Stop-session dialog (3 options) */
        .stop-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .stop-overlay.open { display: flex; }
        .stop-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 20px 24px;
            min-width: 300px;
            max-width: 380px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .stop-box p {
            margin: 0 0 16px;
            color: #d0d0e0;
            font-size: 14px;
            line-height: 1.4;
        }
        .stop-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .stop-actions button {
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid #2a2a5a;
            cursor: pointer;
            font-size: 13px;
            width: 100%;
            text-align: left;
        }
        .stop-actions .stop-graceful {
            background: #1a3a2a;
            border-color: #2a5a3a;
            color: #a0e0b0;
        }
        .stop-actions .stop-graceful:hover { background: #2a4a3a; }
        .stop-actions .stop-kill {
            background: #3a1a1a;
            border-color: #5a2a2a;
            color: #e0a0a0;
        }
        .stop-actions .stop-kill:hover { background: #4a2a2a; }
        .stop-actions .stop-cancel {
            background: transparent;
            color: #b0b0c8;
            text-align: center;
        }
        .stop-actions .stop-cancel:hover { background: #1e1e3e; }

        /* About modal */
        .about-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .about-overlay.open { display: flex; }
        .about-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 24px 28px;
            min-width: 300px;
            max-width: 420px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
        }
        .about-box h2 {
            font-size: 18px;
            color: #8080ff;
            margin: 0 0 4px;
            font-weight: 600;
        }
        .about-box .about-version {
            font-size: 11px;
            color: #7878a0;
            margin-bottom: 14px;
        }
        .about-box p {
            font-size: 13px;
            color: #b0b0c0;
            line-height: 1.5;
            margin: 0 0 12px;
        }
        .about-box a {
            color: #7070cc;
            text-decoration: none;
        }
        .about-box a:hover { text-decoration: underline; }
        .about-box .about-section {
            font-size: 11px;
            color: #7878a0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 14px 0 6px;
        }
        .about-box ul {
            list-style: none;
            padding: 0;
            margin: 0 0 10px;
            font-size: 12px;
            color: #b0b0c8;
        }
        .about-box ul li { padding: 2px 0; }
        .about-close {
            position: absolute;
            top: 10px;
            right: 12px;
            background: none;
            border: none;
            color: #7878a0;
            font-size: 18px;
            cursor: pointer;
            padding: 2px 6px;
            line-height: 1;
        }
        .about-close:hover { color: #c0c0e0; }
        .menu-btn {
            background: none;
            border: none;
            color: #7878a0;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .menu-btn:hover { color: #a0a0d0; }

        /* Hamburger dropdown */
        .menu-wrapper { position: absolute; right: 16px; }
        .menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            min-width: 140px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 400;
            overflow: hidden;
        }
        .menu-dropdown.open { display: block; }
        .menu-dropdown a {
            display: block;
            padding: 8px 14px;
            font-size: 13px;
            color: #c0c0e0;
            text-decoration: none;
            cursor: pointer;
        }
        .menu-dropdown a:hover { background: #1e1e4e; }
        .menu-dropdown .menu-sep {
            height: 1px;
            background: #2a2a5a;
            margin: 2px 0;
        }

        /* Directory picker */
        .dir-picker {
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            border-radius: 5px;
            margin-top: 2px;
            max-height: 200px;
            overflow-y: auto;
        }

        .dir-picker .dir-current {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid #1a1a3a;
            font-size: 12px;
            color: #8080ff;
            word-break: break-all;
        }

        .dir-picker .dir-current button {
            flex-shrink: 0;
            background: none;
            border: none;
            color: #9898b0;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .dir-picker .dir-current button:hover {
            background: #1a1a3e;
            color: #e0e0e0;
        }

        .dir-picker .dir-entry {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #c0c0e0;
        }

        .dir-picker .dir-entry:hover { background: #1a1a3e; }
        .dir-picker .dir-icon { color: #6060aa; font-size: 11px; }

        .dir-picker .dir-empty {
            padding: 8px 10px;
            font-size: 11px;
            color: #505070;
        }

        /* Content area */
        .content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-width: 0;
        }

        /* Placement menu — anchored to sidebar session item */
        .placement-menu {
            display: none;
            position: absolute;
            z-index: 600;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            padding: 4px;
            gap: 2px;
        }
        .placement-menu.open { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: auto auto auto auto auto; width: 120px; }
        .placement-menu button {
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            color: #c0c0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            padding: 6px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .placement-menu button:hover { background: #2a2a6a; border-color: #4a4aaa; color: #fff; }
        .placement-menu .pm-top    { grid-column: 2; grid-row: 2; }
        .placement-menu .pm-left   { grid-column: 1; grid-row: 3; }
        .placement-menu .pm-right  { grid-column: 3; grid-row: 3; }
        .placement-menu .pm-bottom { grid-column: 2; grid-row: 4; }
        .placement-menu .pm-title  { grid-column: 1 / 4; text-align: center; font-size: 11px; color: #9898b0; padding: 2px 0 4px; }
        .placement-menu .pm-status { grid-column: 1 / 4; text-align: center; font-size: 9px; color: #7878a0; padding: 2px 0 0; min-height: 14px; white-space: nowrap; }
        .placement-menu .pm-center { grid-column: 2; grid-row: 3; background: #0a0a1a; border-color: #1a1a3a; color: #9898b0; font-size: 14px; }
        .placement-menu .pm-center:hover { background: #1a1a3e; color: #fff; border-color: #4a4aaa; }

        /* Panels container */
        #panels {
            flex: 1;
            display: flex;
            overflow: hidden;
            background: #0a0a1a;
            /* Shrinks when extra-keys bar is visible so content isn't hidden */
            padding-bottom: var(--extra-keys-height, 0px);
        }

        /* Split panes */
        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .split-container.vertical { flex-direction: column; }
        .split-container.horizontal { flex-direction: row; }

        .split-pane {
            flex: 1;
            overflow: hidden;
            display: flex;
            min-width: 100px;
            min-height: 80px;
        }

        .split-handle {
            flex-shrink: 0;
            background: #1e1e3e;
            transition: background 0.15s;
            position: relative;
        }

        .split-handle:hover, .split-handle.dragging {
            background: #4a4aaa;
        }

        .split-handle.h-handle {
            width: 5px;
            cursor: col-resize;
        }
        .split-handle.v-handle {
            height: 5px;
            cursor: row-resize;
        }

        /* Panel */
        .panel {
            display: flex;
            flex-direction: column;
            background: #12122a;
            overflow: hidden;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .panel-header {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: #0e0e24;
            border-bottom: 1px solid #1e1e3e;
            font-size: 12px;
            min-height: 32px;
        }

        .panel-header .panel-title {
            flex: 1;
            text-align: center;
            font-weight: 500;
            color: #a0a0d0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .panel-focused .panel-header { background: #1a1a48; border-bottom: 1px solid #4040aa; }
        .panel-focused .panel-header .panel-title { color: #d0d0ff; }
        .panel-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-header button {
            background: none; border: none; color: #7878a0;
            cursor: pointer; font-size: 16px; padding: 4px 6px; line-height: 1;
        }
        .panel-header button:hover { color: #c0c0e0; }
        .panel-header button.close-btn:hover { color: #ff6666; }
        .panel-header .font-btn { font-size: 13px; font-weight: 600; }
        .panel-header .theme-btn { padding: 3px 6px; display: flex; align-items: center; }
        .theme-ring {
            display: inline-block;
            width: 12px; height: 12px;
            border-radius: 50%;
            border: 2px solid;
            box-sizing: border-box;
        }
        .theme-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 2px;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            min-width: 110px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 500;
            overflow: hidden;
        }
        .theme-menu.open { display: block; }
        .theme-menu a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            font-size: 12px;
            color: #c0c0e0;
            text-decoration: none;
            cursor: pointer;
        }
        .theme-menu a:hover { background: #1e1e4e; }
        .theme-menu a.active { color: #8080ff; }
        .theme-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .theme-menu a.active .theme-dot {
            outline: 2px solid;
            outline-offset: 1px;
        }

        .extra-keys-bar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 600;
            display: none;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .extra-keys-bar.visible { display: flex; flex-direction: column; align-items: flex-end; }
        .extra-keys-chevron {
            position: absolute;
            right: 8px;
            top: -18px;
            padding: 2px 10px;
            cursor: pointer;
            color: #7878a0;
            font-size: 10px;
            line-height: 1;
            background: #0e0e24;
            border: 1px solid #2a2a5a;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            -webkit-tap-highlight-color: transparent;
            z-index: 1;
        }
        .extra-keys-chevron:active { color: #a0a0d0; }
        .extra-keys-drawer {
            width: 100%;
            background: #0e0e24;
            border-top: 1px solid #2a2a5a;
            overflow: hidden;
        }
        .extra-keys-bar.collapsed .extra-keys-drawer { display: none; }
        .extra-keys-bar.collapsed .extra-keys-chevron { opacity: 0.5; }
        .extra-keys-bar.collapsed .extra-keys-chevron:active { opacity: 1; }
        .extra-keys-rows {
            display: flex;
            flex-direction: row;
            padding: 3px 4px;
            gap: 2px;
        }
        .extra-keys-cols {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }
        .extra-keys-row {
            display: flex;
            gap: 2px;
        }
        .extra-keys-row button {
            background: #1a1a3a;
            border: 1px solid #2a2a5a;
            color: #b0b0d0;
            font-size: 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            padding: 10px 0;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
            min-width: 0;
            text-align: center;
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .extra-keys-row button:active { background: #2a2a5a; color: #e0e0ff; }
        .ek-attach-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #1a1a3a;
            border: 1px solid #2a2a5a;
            color: #b0b0d0;
            border-radius: 4px;
            cursor: pointer;
            padding: 0 12px;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .ek-attach-btn:active { background: #2a2a5a; color: #e0e0ff; }
        .ek-attach-btn svg { pointer-events: none; }
        .extra-keys-row button.modifier-active {
            background: #3a3a7a;
            color: #ffffff;
            border-color: #5050aa;
        }

        .panel-terminal-outer {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .panel-terminal {
            /* calc leaves room for the absolutely-positioned scroll proxy */
            width: calc(100% - 8px);
            height: 100%;
            overflow-x: auto;
            overflow-y: hidden;
        }
        @media (max-width: 700px) {
            .panel-terminal { width: calc(100% - 16px); }
        }

        .terminal-wrapper {
            width: 100%;
            height: 100%;
            /* min-width is set dynamically from JS after measuring char width */
            /* We handle all touch gestures in JS (scroll, tap, momentum).
               touch-action:none prevents the browser from intercepting. */
            touch-action: none;
        }

        .xterm-scroll-proxy {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            z-index: 5;
            background: #0a0a1a;
            touch-action: none;
        }
        @media (max-width: 700px) {
            .xterm-scroll-proxy { width: 16px; }
        }
        .xterm-scroll-thumb {
            position: absolute;
            right: 1px;
            width: 6px;
            min-height: 20px;
            background: #2a2a5a;
            border-radius: 3px;
            transition: background 0.15s;
            cursor: pointer;
            touch-action: none;
        }
        @media (max-width: 700px) {
            .xterm-scroll-thumb { width: 10px; right: 3px; }
        }
        .xterm-scroll-thumb:hover,
        .xterm-scroll-thumb.active {
            background: #3a3a7a;
        }

        /* Horizontal scroll proxy — mirrors .panel-terminal scrollLeft */
        .xterm-hscroll-proxy {
            position: absolute;
            left: 0;
            right: 8px;
            bottom: 0;
            height: 6px;
            z-index: 5;
            display: none;
        }
        @media (max-width: 700px) {
            .xterm-hscroll-proxy { right: 16px; }
        }
        .xterm-hscroll-thumb {
            position: absolute;
            bottom: 1px;
            height: 4px;
            min-width: 20px;
            background: #2a2a5a;
            border-radius: 2px;
            transition: background 0.15s;
        }

        /* .xterm fills the pinned wrapper height so the viewport
           (position:absolute;top:0;bottom:0) matches the visible area. */
        .terminal-wrapper .xterm { height: 100%; }

        /* Hide xterm's native scrollbar — we use the proxy overlay instead */
        .panel-terminal .xterm .xterm-viewport::-webkit-scrollbar { display: none; }
        .panel-terminal .xterm .xterm-viewport { scrollbar-width: none !important; }


        .panel-terminal pre {
            padding: 8px 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px; line-height: 1.4;
            white-space: pre-wrap; word-wrap: break-word;
            overflow-y: auto; height: 100%; color: #d0d0d0;
        }

        /* Thin scrollbars */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #2a2a5a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #3a3a7a; }
        /* Firefox */
        * { scrollbar-width: thin; scrollbar-color: #2a2a5a transparent; }

        /* Fallback input bar (only shown when xterm.js unavailable) */
        .panel-input {
            padding: 6px 8px;
            border-top: 1px solid #1e1e3e;
            background: #0e0e24;
        }

        .panel-input input {
            width: 100%;
            padding: 6px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            outline: none;
        }

        .panel-input input:focus { border-color: #4a4aaa; }

        /* Empty state */
        .empty-state {
            display: flex; align-items: center; justify-content: center;
            height: 100%; width: 100%;
            color: #404060; font-size: 14px;
            flex-direction: column; gap: 8px;
        }

        .empty-state .icon { font-size: 48px; opacity: 0.3; }

        /* Sidebar chevron toggle — sticks to sidebar edge */
        .drawer-toggle {
            position: absolute;
            top: 0;
            right: -16px;
            z-index: 301;
            background: #10102a;
            border: 1px solid #2a2a5a;
            border-left: none;
            color: #8080c0;
            font-size: 14px;
            width: 16px;
            height: 36px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        .drawer-toggle:hover { color: #c0c0e0; }

        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 299;
        }
        .sidebar-overlay.open { display: block; }

        /* Collapsible sidebar */
        .sidebar {
            position: relative;
            transition: width 0.2s ease, min-width 0.2s ease;
        }
        .layout.sidebar-collapsed .sidebar {
            width: 0;
            min-width: 0;
            border-right: none;
        }
        .layout.sidebar-collapsed .sidebar > *:not(.drawer-toggle) {
            display: none;
        }

        @media (max-width: 700px) {
            .sidebar {
                position: fixed;
                top: 0; left: 0; bottom: 0;
                width: 260px;
                min-width: 260px;
                z-index: 300;
                transform: translateX(-100%);
                transition: transform 0.2s ease;
            }
            .sidebar.open { transform: translateX(0); }
            .layout.sidebar-collapsed .sidebar {
                width: 260px;
                min-width: 260px;
                overflow: visible;
            }
            .drawer-toggle {
                left: 260px;
                right: auto;
                width: 20px;
                border-radius: 0 6px 6px 0;
            }
        }

        /* Server management dialog */
        .servers-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .servers-overlay.open { display: flex; }
        .servers-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 24px 28px;
            min-width: 340px;
            max-width: 480px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }
        .servers-box h2 {
            font-size: 16px;
            color: #8080ff;
            margin: 0 0 16px;
            font-weight: 600;
        }
        /* ── Settings dialog ── */
        .settings-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .settings-overlay.open { display: flex; }
        .settings-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 24px 28px;
            min-width: 400px;
            max-width: 560px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }
        .settings-box h2 {
            font-size: 16px;
            color: #8080ff;
            margin: 0 0 16px;
            font-weight: 600;
        }
        .settings-section {
            margin-bottom: 16px;
        }
        .settings-section-title {
            font-size: 11px;
            color: #9898b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        .settings-cmd-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            border-bottom: 1px solid #1a1a3a;
            font-size: 13px;
        }
        .settings-cmd-row .cmd-label {
            color: #c0c0e0;
            min-width: 100px;
            font-weight: 500;
        }
        .settings-cmd-row .cmd-command {
            color: #8888a8;
            flex: 1;
            font-family: monospace;
            font-size: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .settings-cmd-row .cmd-actions {
            display: flex;
            gap: 4px;
        }
        .settings-cmd-row .cmd-actions button {
            background: none;
            border: none;
            color: #7878a0;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 4px;
        }
        .settings-cmd-row .cmd-actions button:hover { color: #a0a0d0; }
        .settings-input {
            width: 100%;
            padding: 6px 8px;
            background: #0e0e2a;
            border: 1px solid #2a2a5a;
            border-radius: 4px;
            color: #c0c0e0;
            font-size: 13px;
            box-sizing: border-box;
        }
        .settings-input:focus {
            outline: none;
            border-color: #4040aa;
        }
        .settings-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .settings-row label {
            font-size: 12px;
            color: #a0a0c0;
            min-width: 120px;
        }
        .settings-row input[type="number"] {
            width: 100px;
            padding: 5px 8px;
            background: #0e0e2a;
            border: 1px solid #2a2a5a;
            border-radius: 4px;
            color: #c0c0e0;
            font-size: 13px;
        }
        .settings-row input[type="number"]:focus {
            outline: none;
            border-color: #4040aa;
        }
        .settings-dir-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }
        .settings-dir-row input {
            flex: 1;
        }
        .settings-dir-row button {
            background: none;
            border: none;
            color: #7878a0;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
        }
        .settings-dir-row button:hover { color: #ff6060; }
        .settings-info-row {
            display: flex;
            gap: 10px;
            font-size: 12px;
            color: #7878a0;
            margin-bottom: 4px;
        }
        .settings-info-row .info-label { color: #9898b0; min-width: 120px; }
        .settings-info-row .info-value { color: #a0a0c0; }
        .settings-hint {
            font-size: 11px;
            color: #7878a0;
            margin-top: 4px;
            line-height: 1.4;
        }
        .settings-hint code {
            background: #0e0e2a;
            padding: 1px 5px;
            border-radius: 3px;
            color: #a0a0c0;
            font-size: 11px;
        }
        .settings-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid #1a1a3a;
        }
        .settings-footer button {
            padding: 6px 16px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
        }
        .settings-footer .btn-save {
            background: #3030aa;
            border: none;
            color: #fff;
        }
        .settings-footer .btn-save:hover { background: #4040cc; }
        .settings-footer .btn-cancel {
            background: none;
            border: 1px solid #2a2a5a;
            color: #9898b0;
        }
        .settings-footer .btn-cancel:hover { border-color: #4040aa; color: #a0a0c0; }
        .settings-footer .btn-reset {
            background: none;
            border: 1px solid #3a2020;
            color: #a07070;
            font-size: 11px;
        }
        .settings-footer .btn-reset:hover { border-color: #6a3030; color: #cc8080; }
        .settings-add-btn {
            background: none;
            border: 1px dashed #2a2a5a;
            border-radius: 4px;
            color: #7878a0;
            cursor: pointer;
            font-size: 12px;
            padding: 4px 10px;
            margin-top: 6px;
        }
        .settings-add-btn:hover { border-color: #4040aa; color: #a0a0d0; }
        .settings-edit-form {
            background: #0e0e2a;
            border: 1px solid #2a2a5a;
            border-radius: 4px;
            padding: 10px;
            margin: 6px 0;
        }
        .settings-edit-form .form-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .settings-edit-form .form-row label {
            font-size: 11px;
            color: #9898b0;
            min-width: 90px;
        }
        .settings-edit-form .form-row input {
            flex: 1;
        }
        .settings-edit-form .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            margin-top: 8px;
        }

        .server-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 4px;
            background: #0e0e24;
        }
        .server-list-item .server-info {
            flex: 1;
            min-width: 0;
        }
        .server-list-item .server-label {
            font-size: 13px;
            color: #c0c0e0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .server-list-item .server-url-text {
            font-size: 11px;
            color: #7878a0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .server-list-item button {
            background: none;
            border: none;
            color: #7878a0;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            flex-shrink: 0;
        }
        .server-list-item button:hover { color: #ff6666; }
        .server-add-form {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        .server-add-form input {
            flex: 1;
            padding: 7px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
        }
        .server-add-form button {
            padding: 7px 14px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        .server-add-form button:hover { background: #3a3a7a; }
        .server-self-info {
            margin-top: 14px;
            padding: 10px;
            background: #0e0e24;
            border-radius: 5px;
            font-size: 12px;
            color: #9898b0;
        }
        .server-self-info .self-url {
            color: #8080ff;
            font-family: 'Consolas', monospace;
            user-select: all;
            cursor: text;
        }

        /* QR Scanner */
        .qr-scanner-container {
            position: relative;
            margin-top: 12px;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }
        .qr-scanner-container video {
            width: 100%;
            display: block;
        }
        .qr-scanner-container canvas { display: none; }
        .qr-scanner-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        .qr-scanner-actions button {
            padding: 7px 14px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }
        .qr-scanner-actions button:hover { background: #3a3a7a; }
        .qr-scanner-actions button.stop-btn { background: #5a2a2a; border-color: #7a3a3a; }
        .qr-scanner-actions button.stop-btn:hover { background: #6a3a3a; }

        .panel-drop-overlay {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(80, 80, 255, 0.12);
            border: 2px dashed #6060ff;
            border-radius: 6px;
            z-index: 20;
            pointer-events: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #a0a0ff;
        }
        .panel-drop-overlay.visible {
            display: flex;
        }

        .upload-toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            color: #e0e0e0;
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        .upload-toast.visible { opacity: 1; }
        .upload-toast.success { border-color: #2a6a2a; background: #1a2e1a; }
        .upload-toast.error { border-color: #6a2a2a; background: #2e1a1a; }

        .upload-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1100;
            align-items: center;
            justify-content: center;
        }
        .upload-overlay.open { display: flex; }
        .upload-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 20px 24px;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .upload-filename {
            color: #d0d0e0;
            font-size: 13px;
            margin: 0 0 12px;
            word-break: break-all;
            line-height: 1.4;
        }
        .upload-status {
            color: #a0a0c0;
            font-size: 13px;
            margin: 0 0 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .upload-spinner {
            width: 16px; height: 16px;
            border: 2px solid #2a2a5a;
            border-top-color: #7070ff;
            border-radius: 50%;
            animation: upload-spin 0.6s linear infinite;
        }
        @keyframes upload-spin { to { transform: rotate(360deg); } }
        .upload-path {
            background: #0e0e20;
            border: 1px solid #2a2a5a;
            border-radius: 4px;
            padding: 8px 10px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: #90d090;
            word-break: break-all;
            margin: 0 0 16px;
            user-select: all;
        }
        .upload-error-msg {
            color: #f09090;
            font-size: 13px;
            margin: 0 0 16px;
        }
        .upload-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .upload-actions button {
            padding: 6px 16px;
            border-radius: 5px;
            border: 1px solid #2a2a5a;
            cursor: pointer;
            font-size: 13px;
            background: transparent;
            color: #b0b0c8;
        }
        .upload-actions button:hover { background: #1e1e3e; }
        .upload-actions .upload-insert {
            background: #1a3a1a;
            border-color: #2a6a2a;
            color: #a0e0a0;
        }
        .upload-actions .upload-insert:hover { background: #2a4a2a; }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="toggleDrawer()"></div>
    <div class="layout" id="layout">
        <aside class="sidebar" id="sidebar">
            <button class="drawer-toggle" id="drawer-toggle" onclick="toggleDrawer()">&#x2039;</button>
            <div class="sidebar-header">
                <h1><a href="https://github.com/somniacs/conductor" target="_blank" style="color:inherit;text-decoration:none"><span style="font-size:1.8em;line-height:0;vertical-align:middle">♭</span> conductor</a> <span id="sidebar-version" style="font-size:9px;font-weight:400;color:#505070"></span></h1>
                <div class="menu-wrapper">
                    <button class="menu-btn" onclick="toggleMenu()" title="Menu">&#9776;</button>
                    <div class="menu-dropdown" id="hamburger-menu">
                        <a onclick="toggleMenu();toggleServersDialog()">Servers</a>
                        <a id="settings-menu-item" style="display:none" onclick="toggleMenu();toggleSettingsDialog()">Settings</a>
                        <div class="menu-sep"></div>
                        <a onclick="toggleMenu();toggleQR()">Link Device</a>
                        <div class="menu-sep"></div>
                        <a href="https://github.com/somniacs/conductor/blob/master/README.md" target="_blank" onclick="toggleMenu()">Help</a>
                        <div class="menu-sep"></div>
                        <a onclick="toggleMenu();toggleAbout()">About</a>
                    </div>
                </div>
            </div>
            <div class="sidebar-actions">
                <button onclick="toggleNewSession()">+ New</button>
            </div>
            <div class="server-status" id="server-status"><span class="spinner"></span>Server disconnected</div>
            <div id="session-list"></div>
            <a class="update-status" id="update-status" target="_blank"></a>
            <div class="new-session" id="new-session-dialog">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <span style="font-size:12px;font-weight:500;color:#a0a0d0;">New Session</span>
                    <button onclick="toggleNewSession()" style="background:none;border:none;color:#7878a0;cursor:pointer;font-size:16px;padding:0 2px;line-height:1;" title="Cancel">&times;</button>
                </div>
                <div id="server-selector-row" style="display:none;">
                    <label>Machine</label>
                    <select id="new-session-server" onchange="onNewSessionServerChange()"></select>
                </div>
                <label>Session name</label>
                <input type="text" id="new-name" placeholder="e.g. research" autocomplete="off">
                <div id="name-error" style="font-size:11px;color:#ff6666;margin-top:2px;display:none;">Name already taken</div>
                <label>Command</label>
                <select id="new-command"></select>
                <label>Working directory</label>
                <div class="dir-picker" id="dir-picker"></div>
                <button class="run-btn" id="run-btn" onclick="createSession()" disabled>Run</button>
            </div>
        </aside>
        <main class="content">
            <div id="panels">
                <div class="empty-state">
                    <div class="icon">&#9837;</div>
                    <div>Select a session or create a new one</div>
                </div>
            </div>
        </main>
    </div>

    <div class="placement-menu" id="placement-menu">
        <div class="pm-title">Placement</div>
        <button class="pm-top" onclick="placeSession('top')" data-hint="Place above">&#x2B06;</button>
        <button class="pm-left" onclick="placeSession('left')" data-hint="Place left">&#x2B05;</button>
        <button class="pm-center" onclick="placeSession('single')" data-hint="Single view">&#x25A3;</button>
        <button class="pm-right" onclick="placeSession('right')" data-hint="Place right">&#x27A1;</button>
        <button class="pm-bottom" onclick="placeSession('bottom')" data-hint="Place below">&#x2B07;</button>
        <div class="pm-status" id="pm-status"></div>
    </div>

    <div class="settings-overlay" id="settings-dialog" onclick="if(event.target===this)toggleSettingsDialog()">
        <div class="settings-box">
            <button class="about-close" onclick="toggleSettingsDialog()">&times;</button>
            <h2>Settings</h2>
            <div id="settings-content"></div>
            <div class="settings-footer">
                <button class="btn-reset" onclick="resetSettings()">Reset to defaults</button>
                <span style="flex:1"></span>
                <button class="btn-cancel" onclick="toggleSettingsDialog()">Cancel</button>
                <button class="btn-save" onclick="saveSettings()">Save</button>
            </div>
        </div>
    </div>

    <div class="about-overlay" id="about-dialog" onclick="if(event.target===this)toggleAbout()">
        <div class="about-box">
            <button class="about-close" onclick="toggleAbout()">&times;</button>
            <h2><span style="font-size:1.4em;vertical-align:middle">♭</span> conductor</h2>
            <div class="about-version">v...</div>
            <p>Local orchestration layer for interactive terminal processes. Run sessions on your workstation, interact from anywhere.</p>
            <div class="about-section">Built with</div>
            <ul>
                <li><a href="https://fastapi.tiangolo.com" target="_blank">FastAPI</a> &mdash; async web framework</li>
                <li><a href="https://xtermjs.org" target="_blank">xterm.js</a> &mdash; terminal rendering</li>
                <li><a href="https://uvicorn.org" target="_blank">Uvicorn</a> &mdash; ASGI server</li>
                <li><a href="https://click.palletsprojects.com" target="_blank">Click</a> &mdash; CLI framework</li>
                <li><a href="https://tailscale.com" target="_blank">Tailscale</a> &mdash; secure remote access</li>
                <li><a href="https://websockets.readthedocs.io" target="_blank">websockets</a> &mdash; real-time terminal I/O</li>
                <li><a href="https://www.python-httpx.org" target="_blank">httpx</a> &mdash; HTTP client</li>
                <li><a href="https://github.com/andfoy/pywinpty" target="_blank">pywinpty</a> &mdash; Windows ConPTY support</li>
                <li><a href="https://github.com/lincolnloop/python-qrcode" target="_blank">qrcode</a> &mdash; QR device linking</li>
            </ul>
            <div class="about-section">Author</div>
            <p>Max Rheiner / <a href="https://www.birdly.com" target="_blank">Somniacs AG</a></p>
            <div class="about-section">License</div>
            <p><a href="https://github.com/somniacs/conductor/blob/master/LICENSE" target="_blank">MIT License</a></p>
            <div class="about-section">Source</div>
            <p style="margin-bottom:0"><a href="https://github.com/somniacs/conductor" target="_blank">github.com/somniacs/conductor</a></p>
        </div>
    </div>

    <div class="about-overlay" id="qr-dialog" onclick="if(event.target===this)toggleQR()">
        <div class="about-box" style="text-align:center;min-width:260px;">
            <button class="about-close" onclick="toggleQR()">&times;</button>
            <h2 style="font-size:16px;margin-bottom:12px;">Link Device</h2>
            <div id="qr-content"></div>
        </div>
    </div>

    <div class="servers-overlay" id="servers-dialog" onclick="if(event.target===this)toggleServersDialog()">
        <div class="servers-box">
            <button class="about-close" onclick="toggleServersDialog()">&times;</button>
            <h2>Servers</h2>
            <div id="servers-list"></div>
            <div id="tailscale-picker" style="margin-top:12px;">
                <label style="display:block;font-size:11px;color:#9898b0;margin-bottom:4px;">Tailscale devices</label>
                <div id="tailscale-picker-content">
                    <div style="font-size:12px;color:#505070;padding:4px 0;">Loading...</div>
                </div>
            </div>
            <div style="margin-top:10px;">
                <label style="display:block;font-size:11px;color:#9898b0;margin-bottom:4px;">Or add manually</label>
                <div class="server-add-form">
                    <input type="text" id="server-url-input" placeholder="http://100.x.x.x:7777" autocomplete="off"
                        onkeydown="if(event.key==='Enter')addServerFromInput()">
                    <button onclick="addServerFromInput()">Add</button>
                    <button onclick="toggleQRScanner()" id="qr-scan-btn" title="Scan QR code">&#x1F4F7;</button>
                </div>
            </div>
            <div id="qr-scanner-area"></div>
            <div class="server-self-info" id="server-self-info"></div>
        </div>
    </div>

    <div class="confirm-overlay" id="confirm-dialog">
        <div class="confirm-box">
            <p id="confirm-msg"></p>
            <div class="confirm-actions">
                <button class="confirm-cancel" id="confirm-no">Cancel</button>
                <button class="confirm-ok" id="confirm-yes">Stop</button>
            </div>
        </div>
    </div>

    <div class="stop-overlay" id="stop-dialog">
        <div class="stop-box">
            <p id="stop-msg"></p>
            <div class="stop-actions">
                <button class="stop-graceful" id="stop-graceful-btn">Stop &amp; keep resumable</button>
                <button class="stop-kill" id="stop-kill-btn">Stop permanently</button>
                <button class="stop-cancel" id="stop-cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <div class="upload-overlay" id="upload-dialog" onclick="if(event.target===this)closeUploadDialog()">
        <div class="upload-box">
            <div class="upload-filename" id="upload-filename"></div>
            <div class="upload-status" id="upload-status"><div class="upload-spinner"></div> Uploading&hellip;</div>
            <div class="upload-path" id="upload-path" style="display:none"></div>
            <div class="upload-error-msg" id="upload-error" style="display:none"></div>
            <div class="upload-actions" id="upload-actions">
                <button onclick="cancelUpload()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="extra-keys-bar" id="extra-keys-bar" onpointerdown="event.preventDefault()">
        <span class="extra-keys-chevron" onpointerdown="event.stopPropagation(); event.preventDefault(); toggleExtraKeysBar()" id="ek-chevron">&#9650;</span>
        <div class="extra-keys-drawer">
            <div class="extra-keys-rows">
                <div class="extra-keys-cols">
                    <div class="extra-keys-row">
                        <button onpointerdown="sendKey('Escape')">ESC</button>
                        <button onpointerdown="sendKey('/')">/</button>
                        <button onpointerdown="sendKey('-')">&#8211;</button>
                        <button onpointerdown="sendKey('Home')">HOME</button>
                        <button onpointerdown="sendKey('ArrowUp')">&uarr;</button>
                        <button onpointerdown="sendKey('End')">END</button>
                        <button onpointerdown="sendKey('PageUp')">PGUP</button>
                    </div>
                    <div class="extra-keys-row">
                        <button onpointerdown="sendKey('Tab')">TAB</button>
                        <button onpointerdown="toggleModifier('ctrl')" id="ek-ctrl">CTRL</button>
                        <button onpointerdown="toggleModifier('alt')" id="ek-alt">ALT</button>
                        <button onpointerdown="sendKey('ArrowLeft')">&larr;</button>
                        <button onpointerdown="sendKey('ArrowDown')">&darr;</button>
                        <button onpointerdown="sendKey('ArrowRight')">&rarr;</button>
                        <button onpointerdown="sendKey('PageDown')">PGDN</button>
                    </div>
                </div>
                <button onpointerdown="event.stopPropagation(); triggerUpload()" title="Upload file" class="ek-attach-btn"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.49"/></svg></button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js" async></script>
    <script>
        // --- Auth ---
        const _conductorToken = (document.querySelector('meta[name="conductor-token"]') || {}).content || null;
        if (_conductorToken) {
            const _origFetch = window.fetch;
            window.fetch = function(input, init) {
                init = init || {};
                init.headers = new Headers(init.headers || {});
                init.headers.set('Authorization', 'Bearer ' + _conductorToken);
                return _origFetch.call(this, input, init);
            };
        }

        // --- State ---
        let sessions = [];
        let panels = [];
        let layoutRoot = null;   // binary tree: { type:'leaf', panelId } | { type:'split', direction, children:[a,b], ratio }
        let _pendingSessionId = null;
        let _pendingSessionName = null;
        let allowedCommands = [];
        let selectedCwd = null;
        let focusedPanelId = null;
        const hasXterm = typeof Terminal !== 'undefined';

        // --- Multi-Server Registry ---
        let servers = [];
        let serverConnected = {};   // serverKey -> boolean
        let _serverConfigs = {};    // serverKey -> { allowed_commands, default_directories }
        let _newSessionServer = 'local';

        function loadServers() {
            try {
                const stored = localStorage.getItem('conductor-servers');
                if (stored) {
                    servers = JSON.parse(stored);
                    // Ensure local server always exists
                    if (!servers.find(s => s.key === 'local')) {
                        servers.unshift({ key: 'local', label: 'This Machine', url: null, enabled: true });
                    }
                }
            } catch (e) {}
            if (!servers.length) {
                servers = [{ key: 'local', label: 'This Machine', url: null, enabled: true }];
            }
            // Clean up labels: strip full DNS names to short device name
            let changed = false;
            servers.forEach(s => {
                if (s.key === 'local') return;
                // Strip star prefix from old format
                let lbl = s.label.replace(/^\u2605\s*/, '');
                // If label looks like a full DNS name (contains dots), keep only first segment
                if (lbl.includes('.') && lbl.match(/\.\w+\.\w+/)) {
                    lbl = lbl.split('.')[0];
                }
                if (lbl !== s.label) { s.label = lbl; changed = true; }
            });
            if (changed) saveServers();
        }

        function saveServers() {
            localStorage.setItem('conductor-servers', JSON.stringify(servers));
        }

        function addServer(url, label) {
            url = url.replace(/\/+$/, '');
            // Ensure protocol
            if (!/^https?:\/\//.test(url)) url = 'http://' + url;
            const key = url.replace(/^https?:\/\//, '');
            if (servers.find(s => s.key === key)) return null;
            const server = { key, label: label || key, url, enabled: true };
            servers.push(server);
            saveServers();
            return server;
        }

        function removeServer(key) {
            if (key === 'local') return;
            servers = servers.filter(s => s.key !== key);
            saveServers();
            delete serverConnected[key];
            delete _serverConfigs[key];
            // Close panels for this server
            const toClose = panels.filter(p => p.server === key).map(p => p.id);
            toClose.forEach(id => closePanel(id));
            // Remove sessions for this server
            sessions = sessions.filter(s => s._server !== key);
            renderSessionList();
            updateServerSelectorVisibility();
        }

        function serverUrl(serverKey, path) {
            if (serverKey === 'local') return path;
            const server = servers.find(s => s.key === serverKey);
            return server ? server.url + path : path;
        }

        function serverWsUrl(serverKey, path) {
            if (serverKey === 'local') {
                return `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}${path}`;
            }
            const server = servers.find(s => s.key === serverKey);
            if (!server) return path;
            return server.url.replace(/^http/, 'ws') + path;
        }

        function compoundId(serverKey, sessionId) {
            if (!_isMultiServer()) return sessionId;
            return serverKey + '::' + sessionId;
        }

        function parseCompoundId(id) {
            const sep = id.indexOf('::');
            if (sep < 0) return { server: 'local', sessionId: id };
            return { server: id.substring(0, sep), sessionId: id.substring(sep + 2) };
        }

        function _isMultiServer() {
            return servers.filter(s => s.enabled).length > 1;
        }

        function getServerLabel(serverKey) {
            const server = servers.find(s => s.key === serverKey);
            return server ? server.label : serverKey;
        }

        // HTML-escape untrusted strings before interpolating into innerHTML
        function escHtml(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }

        function setServerConnectedStatus(serverKey, connected) {
            const prev = serverConnected[serverKey];
            serverConnected[serverKey] = connected;
            // Main status bar tracks local server
            const el = document.getElementById('server-status');
            if (serverConnected['local'] === false) {
                el.classList.add('disconnected');
            } else {
                el.classList.remove('disconnected');
            }
            // Update server selector when connection status changes
            if (prev !== connected) updateServerSelectorVisibility();
        }

        // Terminal color scheme presets
        const THEMES = {
            default: {
                label: 'Default', dot: '#12122a',
                background: '#12122a', foreground: '#d0d0e0',
                cursor: '#8080ff', selectionBackground: '#3a3a7a',
                black: '#000000', red: '#ff5555', green: '#50fa7b', yellow: '#f1fa8c',
                blue: '#6272a4', magenta: '#ff79c6', cyan: '#8be9fd', white: '#f8f8f2',
            },
            dark: {
                label: 'Dark', dot: '#000000',
                background: '#000000', foreground: '#c0c0c0',
                cursor: '#ffffff', selectionBackground: '#333333',
                black: '#000000', red: '#cc0000', green: '#4e9a06', yellow: '#c4a000',
                blue: '#3465a4', magenta: '#75507b', cyan: '#06989a', white: '#d3d7cf',
            },
            mid: {
                label: 'Mid', dot: '#1e1e2e',
                background: '#1e1e2e', foreground: '#cdd6f4',
                cursor: '#f5e0dc', selectionBackground: '#45475a',
                black: '#45475a', red: '#f38ba8', green: '#a6e3a1', yellow: '#f9e2af',
                blue: '#89b4fa', magenta: '#f5c2e7', cyan: '#94e2d5', white: '#bac2de',
            },
            bright: {
                label: 'Bright', dot: '#fafafa',
                background: '#fafafa', foreground: '#383a42',
                cursor: '#526eff', selectionBackground: '#bfceff',
                black: '#383a42', red: '#e45649', green: '#50a14f', yellow: '#c18401',
                blue: '#4078f2', magenta: '#a626a4', cyan: '#0184bc', white: '#fafafa',
            },
            bernstein: {
                label: 'Bernstein', dot: '#ffb000',
                background: '#1a0e00', foreground: '#ffb000',
                cursor: '#ffb000', selectionBackground: '#4a2800',
                black: '#1a0e00', red: '#ffb000', green: '#ffb000', yellow: '#ffb000',
                blue: '#ffb000', magenta: '#ffb000', cyan: '#ffb000', white: '#ffb000',
                brightBlack: '#805800', brightRed: '#ffb000', brightGreen: '#ffb000', brightYellow: '#ffb000',
                brightBlue: '#ffb000', brightMagenta: '#ffb000', brightCyan: '#ffb000', brightWhite: '#ffb000',
            },
            green: {
                label: 'Green', dot: '#33ff00',
                background: '#001a00', foreground: '#33ff00',
                cursor: '#33ff00', selectionBackground: '#0a4400',
                black: '#001a00', red: '#33ff00', green: '#33ff00', yellow: '#33ff00',
                blue: '#33ff00', magenta: '#33ff00', cyan: '#33ff00', white: '#33ff00',
                brightBlack: '#1a8000', brightRed: '#33ff00', brightGreen: '#33ff00', brightYellow: '#33ff00',
                brightBlue: '#33ff00', brightMagenta: '#33ff00', brightCyan: '#33ff00', brightWhite: '#33ff00',
            },
        };
        const THEME_ORDER = ['default', 'dark', 'mid', 'bright', 'bernstein', 'green'];

        // Return a contrasting grey for the ring around a dot
        function contrastGrey(hex) {
            const c = hex.replace('#', '');
            const r = parseInt(c.substring(0, 2), 16);
            const g = parseInt(c.substring(2, 4), 16);
            const b = parseInt(c.substring(4, 6), 16);
            const lum = (r * 299 + g * 587 + b * 114) / 1000;
            return lum > 128 ? '#404040' : '#c0c0c0';
        }

        // Debounce helper
        function debounce(fn, ms) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => fn(...args), ms);
            };
        }

        // Core fit logic — can be called directly (synchronous) or via debounce.
        function _fitPanelCore(p) {
            if (!p.fitAddon || !p._termOpened) return;
            const target = p._termWrapper || p._termEl;
            const scrollContainer = target.parentElement; // .panel-terminal

            // Use PTY dimensions if known (host terminal is the authority),
            // otherwise fall back to fit addon for browser-only sessions.
            if (p._ptyRows && p._ptyCols) {
                // CLI terminal owns columns (for correct line wrapping).
                // Rows always match the visible panel area:
                //  - growing the panel pulls scrollback into view
                //  - shrinking pushes lines to scrollback
                //  - scrollbar only appears when content overflows
                //
                // No fitAddon.fit() — read cell dimensions from xterm's
                // renderer directly to avoid an intermediate resize that
                // would reflow the buffer and drift the cursor.

                // 1. Get cell dimensions from the renderer
                let cellWidth = 8, cellHeight = 14;
                try {
                    const d = p.terminal._core._renderService.dimensions;
                    if (d && d.css && d.css.cell) {
                        if (d.css.cell.width > 0) cellWidth = d.css.cell.width;
                        if (d.css.cell.height > 0) cellHeight = d.css.cell.height;
                    }
                } catch (e) {
                    if (p.terminal.cols > 0 && target.clientWidth > 0) {
                        cellWidth = target.clientWidth / p.terminal.cols;
                    }
                }

                // 2. Set min-width for PTY columns (horizontal scroll if needed)
                target.style.minWidth = Math.ceil(p._ptyCols * cellWidth) + 'px';

                // 3. Pin wrapper height (clientHeight subtracts scrollbar)
                const visH = scrollContainer.clientHeight;
                if (visH > 0) {
                    target.style.height = visH + 'px';
                } else {
                    requestAnimationFrame(() => _fitPanelCore(p));
                    return;
                }

                // 4. Rows = visible area.  Single resize, no oscillation.
                const visibleRows = Math.max(1, Math.floor(visH / cellHeight));
                if (p.terminal.cols !== p._ptyCols || p.terminal.rows !== visibleRows) {
                    p.terminal.resize(p._ptyCols, visibleRows);
                }
            } else {
                // Browser-only session — reset any CLI-owned dimensions
                target.style.minWidth = '';
                target.style.width = '';
                target.style.height = '';

                try {
                    p.fitAddon.fit();
                } catch (e) { return; }

                // Set min-width for MIN_COLS
                if (p.terminal.cols > 0 && target.clientWidth > 0) {
                    const charWidth = target.clientWidth / p.terminal.cols;
                    target.style.minWidth = Math.ceil(MIN_COLS * charWidth) + 'px';
                }
                // Pin height to visible area (accounts for horizontal scrollbar).
                // Guard against 0 on mobile.
                const visH2 = scrollContainer.clientHeight;
                if (visH2 > 0) {
                    target.style.height = visH2 + 'px';
                } else {
                    requestAnimationFrame(() => _fitPanelCore(p));
                    return;
                }
                try { p.fitAddon.fit(); } catch (e) {}

                if (p.terminal.cols < MIN_COLS) {
                    p.terminal.resize(MIN_COLS, p.terminal.rows);
                }
                syncResizeToPTY(p);
            }
        }

        // Debounced fit + resize per panel.
        // Batches rapid ResizeObserver / window resize events into one fit() call.
        const _panelFitters = {};
        function fitPanel(panel) {
            if (!_panelFitters[panel.id]) {
                _panelFitters[panel.id] = debounce(_fitPanelCore, 100);
            }
            _panelFitters[panel.id](panel);
        }

        // --- Config ---
        async function fetchConfig(serverKey) {
            serverKey = serverKey || 'local';
            try {
                const resp = await fetch(serverUrl(serverKey, '/config'));
                const cfg = await resp.json();
                _serverConfigs[serverKey] = cfg;
                if (serverKey === 'local' && cfg.config_version !== undefined) {
                    _lastConfigVersion = cfg.config_version;
                }
                if (serverKey === _newSessionServer) {
                    allowedCommands = cfg.allowed_commands || [];
                    populateCommandSelect();
                    browseTo('~', serverKey);
                }
            } catch (e) {}
        }

        function populateCommandSelect() {
            const sel = document.getElementById('new-command');
            sel.innerHTML = allowedCommands.map(c =>
                `<option value="${c.command}">${c.label}</option>`
            ).join('');
        }

        // --- Directory Browser ---
        async function browseTo(path, serverKey) {
            serverKey = serverKey || _newSessionServer;
            try {
                const resp = await fetch(serverUrl(serverKey, `/browse?path=${encodeURIComponent(path)}`));
                const data = await resp.json();
                selectedCwd = data.current;
                renderDirPicker(data, serverKey);
                validateNewSession();
            } catch (e) {}
        }

        function renderDirPicker(data, serverKey) {
            const picker = document.getElementById('dir-picker');
            const shortPath = data.current.replace(/^\/home\/[^/]+/, '~').replace(/^C:\\Users\\[^\\]+/, '~');
            let html = `
                <div class="dir-current">
                    ${data.parent ? `<button onclick="browseTo('${data.parent.replace(/'/g, "\\'")}', '${serverKey}')" title="Go up">&#8592;</button>` : ''}
                    <span>${shortPath}</span>
                </div>
            `;
            if (data.directories.length === 0) {
                html += '<div class="dir-empty">No subdirectories</div>';
            } else {
                html += data.directories.map(d =>
                    `<div class="dir-entry" onclick="browseTo('${d.path.replace(/'/g, "\\'")}', '${serverKey}')">
                        <span class="dir-icon">&#128193;</span>
                        <span>${d.name}</span>
                    </div>`
                ).join('');
            }
            picker.innerHTML = html;
        }

        // --- Session List ---
        // Per-server session cache — updated incrementally as servers respond.
        const _serverSessions = {};

        async function fetchAllSessions() {
            const enabledServers = servers.filter(s => s.enabled);

            // Fire all fetches concurrently. Each one updates the UI
            // immediately when it resolves — no waiting for slow servers.
            const promises = enabledServers.map(async (srv) => {
                const url = serverUrl(srv.key, '/sessions');
                const ctrl = new AbortController();
                const timer = setTimeout(() => ctrl.abort(), 4000);
                try {
                    const resp = await fetch(url, { signal: ctrl.signal });
                    clearTimeout(timer);
                    const data = await resp.json();
                    setServerConnectedStatus(srv.key, true);
                    // Check config version header (local server only)
                    if (srv.key === 'local') {
                        const cv = resp.headers.get('X-Config-Version');
                        if (cv !== null) {
                            const ver = parseInt(cv);
                            if (_lastConfigVersion >= 0 && ver !== _lastConfigVersion) {
                                _refreshConfig();
                            }
                            _lastConfigVersion = ver;
                        }
                    }
                    const serverSessions = data;
                    serverSessions.forEach(s => {
                        s._server = srv.key;
                        s._compoundId = compoundId(srv.key, s.id);
                    });
                    _serverSessions[srv.key] = serverSessions;
                } catch (e) {
                    clearTimeout(timer);
                    setServerConnectedStatus(srv.key, false);
                    _serverSessions[srv.key] = [];
                    const stalePanels = panels.filter(p => p.server === srv.key).map(p => p.id);
                    stalePanels.forEach(id => closePanel(id));
                }
                // Rebuild combined list and render after each server responds
                _rebuildSessionList();
            });

            await Promise.allSettled(promises);
        }

        function _rebuildSessionList() {
            const allSessions = [];
            for (const key of Object.keys(_serverSessions)) {
                allSessions.push(..._serverSessions[key]);
            }
            sessions = allSessions;

            // Close panels whose session no longer exists on the server.
            const knownIds = new Set(allSessions.map(s => s._compoundId));
            const orphaned = panels.filter(p => !knownIds.has(p.id));
            orphaned.forEach(p => closePanel(p.id));

            renderSessionList();
            validateNewSession();
        }

        function getCommandLabel(command) {
            const match = allowedCommands.find(c => c.command === command);
            return match ? match.label : command.split(/\s/)[0];
        }

        let _lastSessionListHtml = '';
        function renderSessionList() {
            const list = document.getElementById('session-list');
            let html;

            const groups = {};
            const serverOrder = servers.filter(s => s.enabled).map(s => s.key);
            serverOrder.forEach(k => { groups[k] = []; });
            sessions.forEach(s => {
                if (!groups[s._server]) groups[s._server] = [];
                groups[s._server].push(s);
            });

            html = '';
            for (const key of serverOrder) {
                const label = getServerLabel(key);
                const connected = serverConnected[key] !== false;
                const dotClass = connected ? 'connected' : 'disconnected';
                html += `<div class="server-group-header">
                    <span class="server-dot ${dotClass}"></span>
                    <span>${escHtml(label)}</span>
                </div>`;
                if (groups[key] && groups[key].length > 0) {
                    html += groups[key].map(s => renderSessionItem(s)).join('');
                } else {
                    html += '<div style="padding:4px 12px;color:#404060;font-size:11px;">No sessions</div>';
                }
            }

            // Skip DOM update when nothing changed — preserves CSS animations
            if (html !== _lastSessionListHtml) {
                _lastSessionListHtml = html;
                list.innerHTML = html;
            }
        }

        function renderSessionItem(s) {
            const cid = s._compoundId || s.id;
            const isOpen = panels.some(p => p.id === cid);
            const isFocused = focusedPanelId === cid;
            const appLabel = getCommandLabel(s.command);
            const isResumable = s.status === 'exited' && s.resume_id;
            const isStopping = s.status === 'stopping';
            const isResuming = _resumingSession === cid;
            // Escape single quotes in compound ID for onclick
            const cidEsc = cid.replace(/'/g, "\\'");
            const nameEsc = s.name.replace(/'/g, "\\'");

            let actions;
            if (isResuming || isStopping) {
                // Session is resuming or shutting down — no action buttons
                actions = '';
            } else if (isResumable) {
                actions = `
                    <button onclick="event.stopPropagation();resumeSession('${cidEsc}')" title="Resume session" style="color:#44dd77;">&#9654;</button>
                    <button onclick="event.stopPropagation();dismissSession('${cidEsc}')" title="Dismiss">&times;</button>
                `;
            } else {
                actions = `<button onclick="event.stopPropagation();killSession('${cidEsc}')" title="Stop">&times;</button>`;
            }

            const statusBadge = isResuming
                ? '<span class="session-status resuming" style="font-size:9px;margin-left:4px;"><span class="spinner"></span>resuming</span>'
                : isStopping
                    ? '<span class="session-status stopping" style="font-size:9px;margin-left:4px;"><span class="spinner"></span>stopping</span>'
                    : isResumable
                        ? '<span class="session-status exited" style="font-size:9px;margin-left:4px;">resumable</span>'
                        : '';

            // Stopping, resuming, and resumable sessions are not clickable
            const clickable = !isStopping && !isResumable && !isResuming;

            return `
                <div class="session-item ${isFocused ? 'focused' : isOpen ? 'open' : ''}" ${clickable ? `onclick="focusSession('${cidEsc}', '${nameEsc}', event)"` : ''}>
                    <div class="session-name">
                        <div>${escHtml(s.name)}${statusBadge}</div>
                        <div style="font-size:10px;color:#7878a0;font-weight:400;">${escHtml(appLabel)}</div>
                    </div>
                    <div class="session-actions">
                        ${actions}
                    </div>
                </div>
            `;
        }

        // --- Panels ---
        function setFocus(id) {
            if (focusedPanelId === id) return;
            focusedPanelId = id;
            // Update panel visual focus
            panels.forEach(p => {
                if (p.element) p.element.classList.toggle('panel-focused', p.id === id);
            });
            renderSessionList();
        }

        function focusSession(id, name, evt) {
            closeDrawer();
            const existing = panels.find(p => p.id === id);
            if (existing) {
                hidePlacementMenu();
                setFocus(id);
                if (existing.terminal) existing.terminal.focus();
                return;
            }
            // If no panels open, open directly
            if (panels.length === 0) {
                openSession(id, name, 'right');
                return;
            }
            // Show placement menu at the click position
            showPlacementMenu(id, name, evt);
        }

        function showPlacementMenu(id, name, evt) {
            _pendingSessionId = id;
            _pendingSessionName = name;
            const menu = document.getElementById('placement-menu');
            // Position at click location
            if (evt) {
                const menuW = 120, menuH = 160;
                let x = evt.clientX - menuW / 2;
                let y = evt.clientY - menuH / 2;
                // Keep within viewport
                x = Math.max(4, Math.min(x, window.innerWidth - menuW - 4));
                y = Math.max(4, Math.min(y, window.innerHeight - menuH - 4));
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
            } else {
                menu.style.left = '220px';
                menu.style.top = '100px';
            }
            menu.classList.add('open');
        }

        function hidePlacementMenu() {
            document.getElementById('placement-menu').classList.remove('open');
            _pendingSessionId = null;
            _pendingSessionName = null;
        }

        function placeSession(direction) {
            if (!_pendingSessionId) return;
            const id = _pendingSessionId;
            const name = _pendingSessionName;
            hidePlacementMenu();
            if (direction === 'single') {
                // Close all other panels, open this one full-screen
                const toClose = panels.map(p => p.id);
                toClose.forEach(pid => closePanel(pid));
                openSession(id, name, 'right');
            } else {
                openSession(id, name, direction);
            }
        }

        // Close placement menu on click-outside or Escape
        document.addEventListener('mousedown', (e) => {
            const menu = document.getElementById('placement-menu');
            if (menu.classList.contains('open') && !menu.contains(e.target)) {
                hidePlacementMenu();
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') hidePlacementMenu();
        });

        // Placement menu status line on hover
        document.getElementById('placement-menu').addEventListener('mouseover', (e) => {
            const btn = e.target.closest('button[data-hint]');
            document.getElementById('pm-status').textContent = btn ? btn.dataset.hint : '';
        });
        document.getElementById('placement-menu').addEventListener('mouseleave', () => {
            document.getElementById('pm-status').textContent = '';
        });

        function openSession(id, name, direction) {
            if (panels.find(p => p.id === id)) return;

            const { server, sessionId } = parseCompoundId(id);
            const panel = {
                id, server, sessionId, name,
                ws: null, terminal: null, fitAddon: null,
                element: null, _resizeObserver: null, _theme: 'default',
                _sizeChecked: false, _dimensionsReady: true, _ptyRows: null, _ptyCols: null,
            };
            panels.push(panel);
            buildPanelElement(panel);
            insertIntoTree(id, direction || 'right');
            layoutPanels();
            setFocus(id);
        }

        // --- Layout Tree ---
        function findLeaf(node, panelId) {
            if (!node) return null;
            if (node.type === 'leaf') return node.panelId === panelId ? node : null;
            return findLeaf(node.children[0], panelId) || findLeaf(node.children[1], panelId);
        }

        function replaceInTree(node, target, replacement) {
            // If root itself is the target
            if (node === target) {
                Object.keys(node).forEach(k => delete node[k]);
                Object.assign(node, replacement);
                return true;
            }
            if (node.type !== 'split') return false;
            for (let i = 0; i < 2; i++) {
                if (node.children[i] === target) {
                    node.children[i] = replacement;
                    return true;
                }
                if (replaceInTree(node.children[i], target, replacement)) return true;
            }
            return false;
        }

        function insertIntoTree(panelId, direction) {
            const newLeaf = { type: 'leaf', panelId };
            if (!layoutRoot) {
                layoutRoot = newLeaf;
                return;
            }
            if (panels.length <= 1) {
                // Only one panel — just set as root
                layoutRoot = newLeaf;
                return;
            }
            const focusedLeaf = findLeaf(layoutRoot, focusedPanelId);
            if (!focusedLeaf) {
                // Fallback: wrap root
                const splitDir = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';
                const first = (direction === 'right' || direction === 'bottom') ? layoutRoot : newLeaf;
                const second = (direction === 'right' || direction === 'bottom') ? newLeaf : layoutRoot;
                layoutRoot = { type: 'split', direction: splitDir, children: [first, second], ratio: 0.5 };
                return;
            }
            const splitDir = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';
            const existingLeaf = { type: 'leaf', panelId: focusedPanelId };
            const first = (direction === 'right' || direction === 'bottom') ? existingLeaf : newLeaf;
            const second = (direction === 'right' || direction === 'bottom') ? newLeaf : existingLeaf;
            const newSplit = { type: 'split', direction: splitDir, children: [first, second], ratio: 0.5 };
            replaceInTree(layoutRoot, focusedLeaf, newSplit);
        }

        function removeFromTree(panelId) {
            if (!layoutRoot) return;
            if (layoutRoot.type === 'leaf') {
                if (layoutRoot.panelId === panelId) layoutRoot = null;
                return;
            }
            _removeLeaf(layoutRoot, null, -1, panelId);
        }

        function _removeLeaf(node, parent, childIdx, panelId) {
            if (node.type === 'leaf') {
                if (node.panelId === panelId && parent) {
                    const sibling = parent.children[1 - childIdx];
                    replaceInTree(layoutRoot, parent, sibling);
                    return true;
                }
                return false;
            }
            if (_removeLeaf(node.children[0], node, 0, panelId)) return true;
            return _removeLeaf(node.children[1], node, 1, panelId);
        }

        function firstLeafId(node) {
            if (!node) return null;
            if (node.type === 'leaf') return node.panelId;
            return firstLeafId(node.children[0]);
        }

        const MIN_COLS = 80;

        // Build the panel DOM + terminal ONCE. This is only called when a session is first opened.
        function buildPanelElement(panel) {
            const div = document.createElement('div');
            div.className = 'panel';

            // Outer wrapper holds the scroll container + the vertical scrollbar proxy.
            // The proxy is absolutely positioned over the outer wrapper so it stays
            // at the right edge regardless of horizontal scroll position.
            const termOuter = document.createElement('div');
            termOuter.className = 'panel-terminal-outer';

            const termEl = document.createElement('div');
            termEl.className = 'panel-terminal';

            // Wrapper enforces min-width so the terminal never shrinks below MIN_COLS.
            // When the panel is narrower, .panel-terminal scrolls horizontally.
            const termWrapper = document.createElement('div');
            termWrapper.className = 'terminal-wrapper';
            termEl.appendChild(termWrapper);
            termOuter.appendChild(termEl);

            // Vertical scroll proxy — absolutely positioned at the right edge of
            // the outer wrapper, outside the horizontal scroll container.
            const scrollProxy = document.createElement('div');
            scrollProxy.className = 'xterm-scroll-proxy';
            const scrollThumb = document.createElement('div');
            scrollThumb.className = 'xterm-scroll-thumb';
            scrollProxy.appendChild(scrollThumb);
            termOuter.appendChild(scrollProxy);

            // Horizontal scroll proxy — at the bottom edge, shows when content
            // is wider than the panel (wide terminal output).
            const hScrollProxy = document.createElement('div');
            hScrollProxy.className = 'xterm-hscroll-proxy';
            const hScrollThumb = document.createElement('div');
            hScrollThumb.className = 'xterm-hscroll-thumb';
            hScrollProxy.appendChild(hScrollThumb);
            termOuter.appendChild(hScrollProxy);

            // Show server name in panel header when multi-server
            const serverLabel = _isMultiServer() ? ` <span style="font-size:10px;color:#7878a0;">(${escHtml(getServerLabel(panel.server))})</span>` : '';

            // panel.id is serverKey::sessionName — safe chars only (validated by _SAFE_NAME + IP:port)
            // Escape for JS string context (defense in depth)
            const pid = panel.id.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            div.innerHTML = `
                <div class="panel-header">
                    <span class="panel-title">${escHtml(panel.name)}${serverLabel}</span>
                    <div class="panel-header-actions" style="position:relative;">
                        <button class="theme-btn" id="theme-btn-${escHtml(panel.id)}" onclick="toggleThemeMenu('${pid}')" title="Color scheme"><span class="theme-ring" style="background:${THEMES['default'].dot};border-color:${contrastGrey(THEMES['default'].dot)}"></span></button>
                        <div class="theme-menu" id="theme-menu-${escHtml(panel.id)}">
                            ${THEME_ORDER.map(k => `<a onclick="event.stopPropagation();setTheme('${pid}','${k}')" data-theme="${k}" data-cursor="${THEMES[k].cursor}"><span class="theme-dot" style="background:${THEMES[k].dot};border-color:${contrastGrey(THEMES[k].dot)}"></span>${THEMES[k].label}</a>`).join('')}
                        </div>
                        <button class="font-btn" onclick="changeFontSize('${pid}', -1)" title="Smaller">&#8722;</button>
                        <button class="font-btn" onclick="changeFontSize('${pid}', 1)" title="Bigger">+</button>
                        <button class="close-btn" onclick="closePanel('${pid}')">&times;</button>
                    </div>
                </div>
            `;
            div.appendChild(termOuter);

            // Hidden file input for file upload
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.id = 'upload-' + panel.id;
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', () => {
                if (fileInput.files && fileInput.files[0]) {
                    uploadFileToSession(panel, fileInput.files[0]);
                    fileInput.value = '';
                }
            });
            div.appendChild(fileInput);

            panel.element = div;
            panel._termEl = termEl;
            panel._termWrapper = termWrapper;
            panel._scrollProxy = scrollProxy;
            panel._scrollThumb = scrollThumb;

            if (hasXterm) {
                const defT = THEMES['default'];
                const term = new Terminal({
                    cursorBlink: true,
                    fontSize: window.innerWidth <= 700 ? 8 : 14,
                    fontFamily: "'Consolas', 'Monaco', 'Courier New', monospace",
                    theme: {
                        background: defT.background, foreground: defT.foreground,
                        cursor: defT.cursor, selectionBackground: defT.selectionBackground,
                        black: defT.black, red: defT.red, green: defT.green, yellow: defT.yellow,
                        blue: defT.blue, magenta: defT.magenta, cyan: defT.cyan, white: defT.white,
                        brightBlack: defT.brightBlack, brightRed: defT.brightRed,
                        brightGreen: defT.brightGreen, brightYellow: defT.brightYellow,
                        brightBlue: defT.brightBlue, brightMagenta: defT.brightMagenta,
                        brightCyan: defT.brightCyan, brightWhite: defT.brightWhite,
                    },
                    scrollback: window.innerWidth <= 700 ? 1000 : 5000,
                    convertEol: false,
                });

                panel.terminal = term;

                if (typeof FitAddon !== 'undefined') {
                    const fitAddon = new FitAddon.FitAddon();
                    term.loadAddon(fitAddon);
                    panel.fitAddon = fitAddon;
                }

                term.onData((data) => {
                    if (panel.ws && panel.ws.readyState === WebSocket.OPEN) {
                        // Apply extra-keys modifiers (Ctrl/Alt) to regular keyboard input
                        if ((_ekMods.ctrl || _ekMods.alt) && data.length === 1) {
                            const ch = data.charCodeAt(0);
                            let seq = data;
                            if (_ekMods.ctrl && ch >= 0x40 && ch <= 0x7e) {
                                // Ctrl + printable char: convert to control code
                                // a-z → 1-26, A-Z → 1-26, [→27, \→28, ]→29, ^→30, _→31
                                seq = String.fromCharCode(ch & 0x1f);
                            } else if (_ekMods.ctrl && ch >= 0x20 && ch < 0x40) {
                                // Ctrl+2 → NUL, Ctrl+6 → RS, etc. — send raw
                                seq = data;
                            }
                            if (_ekMods.alt) {
                                seq = '\x1b' + seq;
                            }
                            panel.ws.send(seq);
                            _clearModifiers();
                            return;
                        }
                        panel.ws.send(data);
                    }
                });
            }

            // Drag-and-drop image upload
            const dropOverlay = document.createElement('div');
            dropOverlay.className = 'panel-drop-overlay';
            dropOverlay.textContent = 'Drop file here';
            div.appendChild(dropOverlay);
            let dragCounter = 0;

            div.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                dropOverlay.classList.add('visible');
            });
            div.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            div.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if (dragCounter <= 0) {
                    dragCounter = 0;
                    dropOverlay.classList.remove('visible');
                }
            });
            div.addEventListener('drop', (e) => {
                e.preventDefault();
                dragCounter = 0;
                dropOverlay.classList.remove('visible');
                const files = e.dataTransfer && e.dataTransfer.files;
                if (files && files.length > 0) {
                    uploadFileToSession(panel, files[0]);
                }
            });

            // Clicking anywhere on the panel sets focus
            div.addEventListener('mousedown', () => setFocus(panel.id));
            div.addEventListener('touchstart', () => setFocus(panel.id), { passive: true });
        }

        // Ensure the xterm terminal is opened into its container and sized correctly.
        // Safe to call multiple times — only opens once.
        function ensureTerminalOpen(panel) {
            if (!panel.terminal || !panel._termEl) return;
            if (panel._termOpened) {
                // Already open — just refit
                fitPanel(panel);
                return;
            }

            // Open into the wrapper (which has min-width for horizontal scroll)
            const target = panel._termWrapper || panel._termEl;
            panel.terminal.open(target);
            panel._termOpened = true;


            // Mobile touch scroll — both axes simultaneously, no direction
            // locking.  Capture phase + stopPropagation prevents xterm's own
            // touch handlers from interfering.  Momentum on both axes.
            //
            // KEY PERF INSIGHT: every vp.scrollTop assignment fires xterm's
            // internal scroll→_handleScroll→refresh(0,rows-1) chain = full
            // re-render.  We rAF-batch vertical updates so at most one
            // scrollTop write happens per frame.
            if ('ontouchstart' in window && window.matchMedia('(max-width: 700px)').matches) {
                let tY = null, tX = null, tMoved = false;
                let tVelX = 0, tVelY = 0, tTime = 0, tMom = null;
                let cachedVp = null;
                const getVp = () => (cachedVp || (cachedVp = target.querySelector('.xterm-viewport')));
                const hScroller = target.parentElement; // .panel-terminal

                // rAF-batched vertical scroll — accumulate dy, apply once/frame.
                // Each scrollTop write triggers xterm's _handleScroll → full
                // re-render.  Batching ensures at most one per frame.
                let pendingDy = 0;
                let vScrollRaf = 0;

                function applyVerticalScroll() {
                    vScrollRaf = 0;
                    if (pendingDy === 0) return;
                    const vp = getVp();
                    if (!vp) { pendingDy = 0; return; }
                    vp.scrollTop += pendingDy;
                    pendingDy = 0;
                }

                function scheduleVScroll(dy) {
                    pendingDy += dy;
                    if (!vScrollRaf) vScrollRaf = requestAnimationFrame(applyVerticalScroll);
                }

                function momTick() {
                    tVelX *= 0.93;
                    tVelY *= 0.93;
                    if (Math.abs(tVelX) < 0.5 && Math.abs(tVelY) < 0.5) { tMom = null; return; }
                    if (Math.abs(tVelY) >= 0.5) scheduleVScroll(tVelY);
                    if (Math.abs(tVelX) >= 0.5) hScroller.scrollLeft += tVelX;
                    tMom = requestAnimationFrame(momTick);
                }

                target.addEventListener('touchstart', (e) => {
                    if (tMom) { cancelAnimationFrame(tMom); tMom = null; }
                    if (vScrollRaf) { cancelAnimationFrame(vScrollRaf); vScrollRaf = 0; pendingDy = 0; }
                    if (e.touches.length === 1) {
                        tY = e.touches[0].clientY;
                        tX = e.touches[0].clientX;
                        tTime = e.timeStamp;
                        tVelX = 0; tVelY = 0; tMoved = false;
                    }
                }, { passive: true, capture: true });

                target.addEventListener('touchmove', (e) => {
                    if (e.touches.length !== 1 || tY === null) return;
                    e.preventDefault();
                    e.stopPropagation();
                    tMoved = true;
                    const dy = tY - e.touches[0].clientY;
                    const dx = tX - e.touches[0].clientX;
                    const dt = e.timeStamp - tTime;
                    tTime = e.timeStamp;
                    tY = e.touches[0].clientY;
                    tX = e.touches[0].clientX;
                    if (dt > 0) { tVelY = dy / dt * 16; tVelX = dx / dt * 16; }
                    // Vertical: rAF-batched (expensive — triggers xterm re-render)
                    scheduleVScroll(dy);
                    // Horizontal: immediate (cheap — plain div, no JS listeners)
                    hScroller.scrollLeft += dx;
                }, { passive: false, capture: true });

                target.addEventListener('touchend', (e) => {
                    const wasTap = !tMoved;
                    if (tMoved) e.stopPropagation();
                    tY = null; tX = null;
                    if (tMoved && (Math.abs(tVelX) > 1.5 || Math.abs(tVelY) > 1.5)) {
                        tMom = requestAnimationFrame(momTick);
                    }
                    tMoved = false;
                    // Tap → focus terminal + scroll to bottom
                    if (wasTap) {
                        panel.terminal.focus();
                        const vp = getVp();
                        if (vp) vp.scrollTop = vp.scrollHeight;
                    }
                }, { passive: true, capture: true });
            }

            if (panel.fitAddon) {
                panel.fitAddon.fit();

                // Measure actual char width and set wrapper min-width so terminal never shrinks below MIN_COLS
                if (panel.terminal.cols > 0 && target.clientWidth > 0) {
                    const charWidth = target.clientWidth / panel.terminal.cols;
                    target.style.minWidth = Math.ceil(MIN_COLS * charWidth) + 'px';
                }
                // Pin wrapper height to visible area (horizontal scrollbar
                // steals vertical space that CSS height:100% doesn't subtract).
                // Guard against 0 on mobile before layout settles.
                // Don't call fit() again here — _fitPanelCore will handle
                // the final sizing (including PTY dimensions if applicable).
                const scrollContainer = target.parentElement;
                const visH = scrollContainer.clientHeight;
                if (visH > 0) {
                    target.style.height = visH + 'px';
                }

                // Set up custom vertical scroll thumb — positioned manually so it
                // always sits at the right edge of the panel, outside horizontal scroll.
                if (panel._scrollProxy && panel._scrollThumb) {
                    const xtermVp = target.querySelector('.xterm-viewport');
                    if (xtermVp) {
                        const thumb = panel._scrollThumb;
                        const track = panel._scrollProxy;

                        let scrollThumbRaf = 0;
                        function syncScrollThumb() {
                            const sh = xtermVp.scrollHeight;
                            const ch = xtermVp.clientHeight;
                            if (sh <= ch) {
                                thumb.style.display = 'none';
                                return;
                            }
                            thumb.style.display = 'block';
                            const trackH = track.clientHeight;
                            const thumbH = Math.max(20, (ch / sh) * trackH);
                            const maxTop = trackH - thumbH;
                            const ratio = xtermVp.scrollTop / (sh - ch);
                            thumb.style.height = thumbH + 'px';
                            thumb.style.top = (ratio * maxTop) + 'px';
                        }
                        // Throttle scroll-driven updates to one per frame
                        function scheduleThumbSync() {
                            if (!scrollThumbRaf) {
                                scrollThumbRaf = requestAnimationFrame(() => {
                                    scrollThumbRaf = 0;
                                    syncScrollThumb();
                                });
                            }
                        }

                        // Sync when xterm viewport scrolls
                        xtermVp.addEventListener('scroll', scheduleThumbSync, { passive: true });

                        // Drag the thumb to scroll the terminal
                        let dragging = false, dragStartY = 0, dragStartST = 0;
                        function onThumbStart(clientY) {
                            dragging = true;
                            dragStartY = clientY;
                            dragStartST = xtermVp.scrollTop;
                            thumb.classList.add('active');
                        }
                        function onThumbMove(clientY) {
                            if (!dragging) return;
                            const sh = xtermVp.scrollHeight;
                            const ch = xtermVp.clientHeight;
                            const trackH = track.clientHeight;
                            const thumbH = Math.max(20, (ch / sh) * trackH);
                            const maxTop = trackH - thumbH;
                            const maxST = sh - ch;
                            const dy = clientY - dragStartY;
                            xtermVp.scrollTop = dragStartST + (dy / maxTop) * maxST;
                        }
                        function onThumbEnd() {
                            dragging = false;
                            thumb.classList.remove('active');
                        }
                        // Mouse
                        thumb.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            onThumbStart(e.clientY);
                            function mm(e) { onThumbMove(e.clientY); }
                            function mu() { onThumbEnd(); document.removeEventListener('mousemove', mm); document.removeEventListener('mouseup', mu); }
                            document.addEventListener('mousemove', mm);
                            document.addEventListener('mouseup', mu);
                        });
                        // Touch — drag anywhere on the track (thumb is too
                        // narrow to hit reliably on mobile).
                        track.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            // Jump to tap position, then start drag
                            const rect = track.getBoundingClientRect();
                            const ratio = (e.touches[0].clientY - rect.top) / rect.height;
                            const maxST = xtermVp.scrollHeight - xtermVp.clientHeight;
                            xtermVp.scrollTop = ratio * maxST;
                            onThumbStart(e.touches[0].clientY);
                            dragStartST = xtermVp.scrollTop;
                        }, { passive: false });
                        track.addEventListener('touchmove', (e) => {
                            e.preventDefault();
                            onThumbMove(e.touches[0].clientY);
                        }, { passive: false });
                        track.addEventListener('touchend', () => onThumbEnd());

                        // Click on track to jump (desktop)
                        track.addEventListener('mousedown', (e) => {
                            if (e.target === thumb) return;
                            const rect = track.getBoundingClientRect();
                            const ratio = (e.clientY - rect.top) / rect.height;
                            const maxST = xtermVp.scrollHeight - xtermVp.clientHeight;
                            xtermVp.scrollTop = ratio * maxST;
                        });

                        syncScrollThumb();
                        // Periodically sync in case buffer grows
                        panel._scrollSyncInterval = setInterval(syncScrollThumb, 500);

                        // --- Horizontal scroll indicator ---
                        const hOuter = target.closest('.panel-terminal-outer');
                        const hTrack = hOuter && hOuter.querySelector('.xterm-hscroll-proxy');
                        const hThumb = hOuter && hOuter.querySelector('.xterm-hscroll-thumb');
                        const hContainer = target.parentElement; // .panel-terminal
                        if (hTrack && hThumb) {
                            function syncHScrollThumb() {
                                const sw = hContainer.scrollWidth;
                                const cw = hContainer.clientWidth;
                                if (sw <= cw) {
                                    hTrack.style.display = 'none';
                                    return;
                                }
                                hTrack.style.display = 'block';
                                const trackW = hTrack.clientWidth;
                                const thumbW = Math.max(20, (cw / sw) * trackW);
                                const maxLeft = trackW - thumbW;
                                const ratio = hContainer.scrollLeft / (sw - cw);
                                hThumb.style.width = thumbW + 'px';
                                hThumb.style.left = (ratio * maxLeft) + 'px';
                            }
                            hContainer.addEventListener('scroll', () => {
                                requestAnimationFrame(syncHScrollThumb);
                            }, { passive: true });
                            syncHScrollThumb();
                            // Also sync periodically (content may change width)
                            panel._hScrollSyncInterval = setInterval(syncHScrollThumb, 500);
                        }
                    }
                }

                // Connect WebSocket — on connect, we'll fetch PTY dimensions
                // and resize xterm.js to match (host terminal is the authority).
                if (!panel.ws) connectWebSocket(panel);

                // Watch the scroll container (not the wrapper) for size changes
                if (typeof ResizeObserver !== 'undefined') {
                    panel._resizeObserver = new ResizeObserver(() => fitPanel(panel));
                    panel._resizeObserver.observe(panel._termEl);
                }
            }
        }

        // Rearrange existing panel elements into the layout using the binary tree.
        function layoutPanels() {
            const container = document.getElementById('panels');

            // Detach all children without destroying them
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            if (!layoutRoot || panels.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">&#9837;</div>
                        <div>Select a session or create a new one</div>
                    </div>`;
                renderSessionList();
                return;
            }

            const dom = renderNode(layoutRoot);
            container.appendChild(dom);

            renderSessionList();

            // Open terminals that haven't been opened yet + refit all
            requestAnimationFrame(() => {
                panels.forEach(p => ensureTerminalOpen(p));
            });
        }

        function renderNode(node) {
            if (node.type === 'leaf') {
                const panel = panels.find(p => p.id === node.panelId);
                const pane = document.createElement('div');
                pane.className = 'split-pane';
                pane.style.flex = '1';
                if (panel && panel.element) pane.appendChild(panel.element);
                return pane;
            }

            // Split node
            const wrapper = document.createElement('div');
            wrapper.className = `split-container ${node.direction}`;

            const child1 = renderNode(node.children[0]);
            const pane1 = wrapInSplitPane(child1);
            pane1.style.flex = String(node.ratio);
            wrapper.appendChild(pane1);

            const handle = document.createElement('div');
            handle.className = `split-handle ${node.direction === 'horizontal' ? 'h-handle' : 'v-handle'}`;
            initDragHandle(handle, wrapper, node.direction, node);
            wrapper.appendChild(handle);

            const child2 = renderNode(node.children[1]);
            const pane2 = wrapInSplitPane(child2);
            pane2.style.flex = String(1 - node.ratio);
            wrapper.appendChild(pane2);

            return wrapper;
        }

        // Ensure a rendered child is always wrapped in a split-pane for consistent flex layout.
        // Leaf nodes already return a split-pane; split nodes return a split-container that needs wrapping.
        function wrapInSplitPane(el) {
            if (el.classList.contains('split-pane')) return el;
            const pane = document.createElement('div');
            pane.className = 'split-pane';
            pane.appendChild(el);
            return pane;
        }

        function changeFontSize(id, delta) {
            const panel = panels.find(p => p.id === id);
            if (!panel || !panel.terminal) return;
            const current = panel.terminal.options.fontSize || 14;
            const next = Math.min(28, Math.max(3, current + delta));
            panel.terminal.options.fontSize = next;
            // Recalculate wrapper min-width for new char size
            const target = panel._termWrapper || panel._termEl;
            if (panel.fitAddon) {
                // Refit to recalculate char width, then apply PTY dimensions
                fitPanel(panel);
            }
        }

        // --- Extra keys toolbar ---
        // Map of key names to the escape sequences they produce.
        const _KEY_SEQS = {
            Escape: '\x1b',
            Tab: '\t',
            '/': '/',
            '-': '-',
            ArrowUp: '\x1b[A',
            ArrowDown: '\x1b[B',
            ArrowRight: '\x1b[C',
            ArrowLeft: '\x1b[D',
            Home: '\x1b[H',
            End: '\x1b[F',
            PageUp: '\x1b[5~',
            PageDown: '\x1b[6~',
        };

        // Global modifier state for the extra-keys bar.
        const _ekMods = { ctrl: false, alt: false };

        function _getFocusedPanel() {
            return panels.find(p => p.id === focusedPanelId);
        }

        let _ekExpanded = localStorage.getItem('ek-expanded') !== 'false'; // default expanded

        function _applyEkState() {
            const bar = document.getElementById('extra-keys-bar');
            const chevron = document.getElementById('ek-chevron');
            if (!bar) return;
            bar.classList.toggle('collapsed', !_ekExpanded);
            if (chevron) chevron.innerHTML = _ekExpanded ? '&#9660;' : '&#9650;';
            _syncExtraKeysHeight();
        }

        function toggleExtraKeysBar() {
            _ekExpanded = !_ekExpanded;
            localStorage.setItem('ek-expanded', _ekExpanded);
            _applyEkState();
        }

        function toggleModifier(mod) {
            _ekMods[mod] = !_ekMods[mod];
            const btn = document.getElementById('ek-' + mod);
            if (btn) btn.classList.toggle('modifier-active', _ekMods[mod]);
        }

        function _clearModifiers() {
            _ekMods.ctrl = false;
            _ekMods.alt = false;
            const ctrlBtn = document.getElementById('ek-ctrl');
            const altBtn = document.getElementById('ek-alt');
            if (ctrlBtn) ctrlBtn.classList.remove('modifier-active');
            if (altBtn) altBtn.classList.remove('modifier-active');
        }

        function sendKey(key) {
            const panel = _getFocusedPanel();
            if (!panel || !panel.ws || panel.ws.readyState !== WebSocket.OPEN) return;

            let seq = _KEY_SEQS[key] || '';

            // When the terminal is in application cursor keys mode (DECCKM),
            // arrows and Home/End use SS3 (ESC O) instead of CSI (ESC [).
            const appMode = panel.terminal?.modes?.applicationCursorKeysMode;
            if (appMode) {
                const appSeqs = {
                    ArrowUp: '\x1bOA', ArrowDown: '\x1bOB',
                    ArrowRight: '\x1bOC', ArrowLeft: '\x1bOD',
                    Home: '\x1bOH', End: '\x1bOF',
                };
                if (appSeqs[key]) seq = appSeqs[key];
            }

            // Ctrl + arrow produces CSI 1;5 <dir> sequences
            if (_ekMods.ctrl) {
                const ctrlArrows = {
                    ArrowUp: '\x1b[1;5A', ArrowDown: '\x1b[1;5B',
                    ArrowRight: '\x1b[1;5C', ArrowLeft: '\x1b[1;5D',
                };
                if (ctrlArrows[key]) seq = ctrlArrows[key];
            }

            // Alt + key: prepend ESC
            if (_ekMods.alt && _KEY_SEQS[key]) {
                seq = '\x1b' + _KEY_SEQS[key];
            }

            if (seq) {
                panel.ws.send(seq);
                _clearModifiers();
            }
        }

        function triggerUpload() {
            const panel = _getFocusedPanel();
            if (!panel) return;
            const inp = document.getElementById('upload-' + panel.id);
            if (inp) inp.click();
        }

        // Measure the extra-keys bar height and set a CSS variable on #panels
        // so the terminal area shrinks instead of being overlapped.
        function _syncExtraKeysHeight() {
            const bar = document.getElementById('extra-keys-bar');
            // When collapsed, the handle overlays the terminal (0 height reserved)
            // so we don't waste vertical space on mobile.
            const visible = bar && bar.classList.contains('visible');
            const collapsed = bar && bar.classList.contains('collapsed');
            const h = (visible && !collapsed) ? bar.offsetHeight : 0;
            document.documentElement.style.setProperty('--extra-keys-height', h + 'px');
            // Refit panels to fill the new available height
            panels.forEach(p => fitPanel(p));
        }

        // Show/hide the extra-keys bar based on virtual keyboard visibility.
        // With `interactive-widget=resizes-visual`, window.innerHeight stays
        // constant while visualViewport.height shrinks when the keyboard opens.
        // Detection uses (innerHeight - vv.height) only — stable across scroll.
        // Hide is debounced so switching panels doesn't flash the bar away.
        let _ekHideTimer = null;
        function _updateExtraKeysPosition() {
            const bar = document.getElementById('extra-keys-bar');
            if (!bar || !window.visualViewport) return;
            const vv = window.visualViewport;
            const keyboardOpen = (window.innerHeight - vv.height) > 100;
            if (keyboardOpen) {
                if (_ekHideTimer) { clearTimeout(_ekHideTimer); _ekHideTimer = null; }
                bar.classList.add('visible');
                // Position just above the keyboard.  With resizes-visual the
                // layout viewport stays full-screen; position:fixed bottom
                // measured from there reliably places us above the keyboard.
                bar.style.top = '';
                bar.style.bottom = (window.innerHeight - vv.offsetTop - vv.height) + 'px';
                _applyEkState();
            } else if (bar.classList.contains('visible')) {
                // Delay hide — keyboard may reopen immediately on panel switch
                if (!_ekHideTimer) {
                    _ekHideTimer = setTimeout(() => {
                        _ekHideTimer = null;
                        // Re-check: keyboard might have reopened during the delay
                        const vv2 = window.visualViewport;
                        if (vv2 && (window.innerHeight - vv2.height) > 100) return;
                        bar.classList.remove('visible');
                        bar.style.top = '';
                        bar.style.bottom = '0';
                        _syncExtraKeysHeight();
                    }, 400);
                }
            }
        }
        if (window.visualViewport) {
            // Resize: keyboard open/close.
            // Scroll (debounced): browser auto-scrolls visual viewport
            // when user switches between panels in split view.
            // Terminal touch scrolling doesn't trigger visualViewport
            // scroll (touch-action: none on wrapper), so this is safe.
            window.visualViewport.addEventListener('resize', _updateExtraKeysPosition);
            window.visualViewport.addEventListener('scroll', debounce(_updateExtraKeysPosition, 80));
        }

        function toggleThemeMenu(id) {
            const menu = document.getElementById(`theme-menu-${id}`);
            // Close all other theme menus first
            document.querySelectorAll('.theme-menu.open').forEach(m => {
                if (m !== menu) m.classList.remove('open');
            });
            menu.classList.toggle('open');
            // Mark active theme
            const panel = panels.find(p => p.id === id);
            const current = panel?._theme || 'default';
            menu.querySelectorAll('a').forEach(a => {
                const isActive = a.dataset.theme === current;
                a.classList.toggle('active', isActive);
                const dot = a.querySelector('.theme-dot');
                if (dot) dot.style.outlineColor = isActive ? '#a0a0a0' : 'transparent';
            });
        }

        function setTheme(id, themeKey) {
            const panel = panels.find(p => p.id === id);
            if (!panel || !panel.terminal) return;
            const t = THEMES[themeKey];
            if (!t) return;
            panel._theme = themeKey;
            const themeObj = {
                background: t.background, foreground: t.foreground,
                cursor: t.cursor, selectionBackground: t.selectionBackground,
                black: t.black, red: t.red, green: t.green, yellow: t.yellow,
                blue: t.blue, magenta: t.magenta, cyan: t.cyan, white: t.white,
            };
            if (t.brightBlack) {
                themeObj.brightBlack = t.brightBlack; themeObj.brightRed = t.brightRed;
                themeObj.brightGreen = t.brightGreen; themeObj.brightYellow = t.brightYellow;
                themeObj.brightBlue = t.brightBlue; themeObj.brightMagenta = t.brightMagenta;
                themeObj.brightCyan = t.brightCyan; themeObj.brightWhite = t.brightWhite;
            }
            panel.terminal.options.theme = themeObj;
            // Also update the panel background to match
            panel.element.style.background = t.background;
            // Update the theme button ring to reflect active theme
            const btn = document.getElementById(`theme-btn-${id}`);
            if (btn) {
                const ring = btn.querySelector('.theme-ring');
                if (ring) {
                    ring.style.background = t.dot;
                    ring.style.borderColor = contrastGrey(t.dot);
                }
            }
            // Update active markers in the menu
            const menu = document.getElementById(`theme-menu-${id}`);
            if (menu) {
                menu.querySelectorAll('a').forEach(a => {
                    const isActive = a.dataset.theme === themeKey;
                    a.classList.toggle('active', isActive);
                    const dot = a.querySelector('.theme-dot');
                    if (dot) dot.style.outlineColor = isActive ? '#a0a0a0' : 'transparent';
                });
                menu.classList.remove('open');
            }
        }

        // Close theme menus when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.theme-menu') && !e.target.closest('.theme-btn')) {
                document.querySelectorAll('.theme-menu.open').forEach(m => m.classList.remove('open'));
            }
        });

        function closePanel(id) {
            const idx = panels.findIndex(p => p.id === id);
            if (idx < 0) return;
            const panel = panels[idx];
            if (panel._resizeObserver) { panel._resizeObserver.disconnect(); panel._resizeObserver = null; }
            if (panel._scrollSyncInterval) { clearInterval(panel._scrollSyncInterval); panel._scrollSyncInterval = null; }
            if (panel.ws) { panel.ws.close(); panel.ws = null; }
            if (panel.terminal) { panel.terminal.dispose(); }
            delete _panelFitters[panel.id];
            panels.splice(idx, 1);
            removeFromTree(id);
            // Move focus to next remaining panel
            if (focusedPanelId === id) {
                focusedPanelId = firstLeafId(layoutRoot);
            }
            layoutPanels();
            if (panels.length === 0) openDrawer();
        }

        // --- Drag handle for resizable splits ---
        function initDragHandle(handle, container, direction, treeNode) {
            let startPos, containerSize;

            function onStart(clientX, clientY) {
                handle.classList.add('dragging');
                startPos = direction === 'horizontal' ? clientX : clientY;
                containerSize = direction === 'horizontal' ? container.offsetWidth : container.offsetHeight;
                document.body.style.cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';
                document.body.style.userSelect = 'none';
            }

            function onMove(clientX, clientY) {
                if (!containerSize) return;
                const currentPos = direction === 'horizontal' ? clientX : clientY;
                const delta = currentPos - startPos;
                const handleSize = direction === 'horizontal' ? 5 : 5;
                const usable = containerSize - handleSize;
                let newRatio = (treeNode.ratio * usable + delta) / usable;
                newRatio = Math.max(0.1, Math.min(0.9, newRatio));
                treeNode.ratio = newRatio;
                // Update flex values on sibling panes
                const panes = container.querySelectorAll(':scope > .split-pane');
                if (panes.length === 2) {
                    panes[0].style.flex = String(newRatio);
                    panes[1].style.flex = String(1 - newRatio);
                }
                startPos = currentPos;
            }

            function onEnd() {
                handle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }

            // Mouse
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                onStart(e.clientX, e.clientY);
                function mm(e) { onMove(e.clientX, e.clientY); }
                function mu() {
                    onEnd();
                    document.removeEventListener('mousemove', mm);
                    document.removeEventListener('mouseup', mu);
                }
                document.addEventListener('mousemove', mm);
                document.addEventListener('mouseup', mu);
            });

            // Touch
            handle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                onStart(t.clientX, t.clientY);
                function tm(e) { const t = e.touches[0]; onMove(t.clientX, t.clientY); }
                function te() {
                    onEnd();
                    document.removeEventListener('touchmove', tm);
                    document.removeEventListener('touchend', te);
                }
                document.addEventListener('touchmove', tm, { passive: false });
                document.addEventListener('touchend', te);
            }, { passive: false });
        }

        // Send current terminal size to PTY via REST
        function syncResizeToPTY(panel) {
            if (!panel.terminal) return;
            // Don't resize until we've checked if a CLI terminal owns the size
            if (!panel._sizeChecked) return;
            // If a CLI terminal owns the PTY size, don't override it
            if (panel._ptyRows && panel._ptyCols) return;
            const cols = panel.terminal.cols;
            const rows = panel.terminal.rows;
            if (cols > 0 && rows > 0) {
                fetch(serverUrl(panel.server, `/sessions/${panel.sessionId}/resize`), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rows, cols, source: 'browser' }),
                });
            }
        }

        // --- File Upload ---
        const _MAX_UPLOAD_SIZE = 10 * 1024 * 1024;

        let _uploadToast = null;
        let _uploadToastTimer = null;

        function showUploadToast(message, type, duration) {
            duration = duration || 3000;
            if (_uploadToast) { _uploadToast.remove(); clearTimeout(_uploadToastTimer); }
            const el = document.createElement('div');
            el.className = 'upload-toast ' + (type || '');
            el.textContent = message;
            document.body.appendChild(el);
            _uploadToast = el;
            requestAnimationFrame(() => el.classList.add('visible'));
            _uploadToastTimer = setTimeout(() => {
                el.classList.remove('visible');
                setTimeout(() => { el.remove(); if (_uploadToast === el) _uploadToast = null; }, 200);
            }, duration);
        }

        let _uploadAbort = null;
        let _uploadPanel = null;
        let _uploadResultPath = null;

        function showUploadDialog(filename) {
            document.getElementById('upload-filename').textContent = filename;
            document.getElementById('upload-status').style.display = '';
            document.getElementById('upload-path').style.display = 'none';
            document.getElementById('upload-error').style.display = 'none';
            document.getElementById('upload-actions').innerHTML = '<button onclick="cancelUpload()">Cancel</button>';
            document.getElementById('upload-dialog').classList.add('open');
        }

        function showUploadSuccess(path) {
            _uploadResultPath = path;
            document.getElementById('upload-status').style.display = 'none';
            document.getElementById('upload-path').style.display = '';
            document.getElementById('upload-path').textContent = path;
            document.getElementById('upload-actions').innerHTML =
                '<button onclick="closeUploadDialog()">Close</button>' +
                '<button onclick="copyUploadPath()" title="Copy path">Copy</button>' +
                '<button class="upload-insert" onclick="insertUploadPath()">Insert</button>';
        }

        function showUploadError(msg) {
            document.getElementById('upload-status').style.display = 'none';
            document.getElementById('upload-error').style.display = '';
            document.getElementById('upload-error').textContent = msg;
            document.getElementById('upload-actions').innerHTML = '<button onclick="closeUploadDialog()">Close</button>';
        }

        function closeUploadDialog() {
            document.getElementById('upload-dialog').classList.remove('open');
            _uploadAbort = null;
            _uploadResultPath = null;
        }

        function cancelUpload() {
            if (_uploadAbort) { _uploadAbort.abort(); _uploadAbort = null; }
            closeUploadDialog();
        }

        function copyUploadPath() {
            if (_uploadResultPath) {
                navigator.clipboard.writeText(_uploadResultPath).then(() => {
                    showUploadToast('Path copied', 'success', 1500);
                });
            }
        }

        function insertUploadPath() {
            if (_uploadResultPath && _uploadPanel && _uploadPanel.ws && _uploadPanel.ws.readyState === WebSocket.OPEN) {
                _uploadPanel.ws.send(_uploadResultPath);
            }
            closeUploadDialog();
        }

        async function uploadFileToSession(panel, blob) {
            if (blob.size > _MAX_UPLOAD_SIZE) {
                showUploadToast('File too large (max 10 MB)', 'error');
                return;
            }
            _uploadPanel = panel;
            _uploadAbort = new AbortController();
            const name = blob.name || 'file';
            const sizeMB = (blob.size / 1024 / 1024).toFixed(1);
            showUploadDialog(name + ' (' + sizeMB + ' MB)');
            try {
                const headers = { 'Content-Type': blob.type || 'application/octet-stream' };
                if (blob.name) headers['X-Filename'] = blob.name;
                const resp = await fetch(serverUrl(panel.server, `/sessions/${panel.sessionId}/upload`), {
                    method: 'POST',
                    headers,
                    body: blob,
                    signal: _uploadAbort.signal,
                });
                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({ detail: resp.statusText }));
                    showUploadError(err.detail || 'Upload failed');
                    return;
                }
                const data = await resp.json();
                showUploadSuccess(data.path);
            } catch (e) {
                if (e.name === 'AbortError') return;
                showUploadError('Upload failed: ' + e.message);
            }
        }

        // Paste handler — intercept file paste, let text paste through
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData && e.clipboardData.items;
            if (!items) return;
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file') {
                    const panel = _getFocusedPanel();
                    if (!panel) return;
                    e.preventDefault();
                    const blob = items[i].getAsFile();
                    if (blob) uploadFileToSession(panel, blob);
                    return;
                }
            }
        });

        // --- WebSocket ---
        function connectWebSocket(panel) {
            const isReconnect = !!panel.ws;
            let wsUrl = serverWsUrl(panel.server, `/sessions/${panel.sessionId}/stream`);
            if (_conductorToken) wsUrl += (wsUrl.includes('?') ? '&' : '?') + 'token=' + encodeURIComponent(_conductorToken);
            const ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';

            ws.onopen = async () => {
                setServerConnectedStatus(panel.server, true);
                // On reconnect, clear terminal to prevent duplicate content from buffer replay
                if (isReconnect && panel.terminal) {
                    panel.terminal.reset();
                }
                panel._bufferReplay = true;
                panel._dimensionsReady = false;

                // Fetch PTY dimensions from the session — host terminal is the authority.
                // If a CLI has set the size, match it; otherwise browser can resize freely.
                try {
                    const info = await fetch(serverUrl(panel.server, `/sessions/${panel.sessionId}`)).then(r => r.json());
                    if (info.resize_source === 'cli' && info.rows && info.cols) {
                        panel._ptyRows = info.rows;
                        panel._ptyCols = info.cols;
                    } else {
                        panel._ptyRows = null;
                        panel._ptyCols = null;
                    }
                } catch (e) {
                    panel._ptyRows = null;
                    panel._ptyCols = null;
                }
                panel._sizeChecked = true;

                // Apply dimensions immediately (not debounced) — buffer data
                // must not be written until the terminal has the correct size.
                _fitPanelCore(panel);

                // Now that dimensions are correct, allow buffered data to flush.
                panel._dimensionsReady = true;
                if (writeBuf.length && !writeRaf) writeRaf = requestAnimationFrame(flushWrites);

                setTimeout(() => { panel._bufferReplay = false; }, 1500);
            };

            // Batch incoming WebSocket data and flush once per animation frame
            // to avoid overwhelming xterm.js with per-chunk renders.
            let writeBuf = [];
            let writeRaf = null;
            function flushWrites() {
                writeRaf = null;
                // Wait for PTY dimensions before writing — otherwise content
                // renders at wrong size and gets corrupted on reflow.
                if (!panel._dimensionsReady) {
                    if (writeBuf.length) writeRaf = requestAnimationFrame(flushWrites);
                    return;
                }
                if (!writeBuf.length || !panel.terminal) return;
                // Concatenate all pending chunks into one write
                let total = 0;
                for (const c of writeBuf) total += c.length;
                const merged = new Uint8Array(total);
                let off = 0;
                for (const c of writeBuf) { merged.set(c, off); off += c.length; }
                writeBuf = [];
                panel.terminal.write(merged);
            }

            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer && event.data.byteLength === 0) return;
                if (!panel._bufferReplay) trackActivity(panel);
                if (panel.terminal) {
                    const data = event.data instanceof ArrayBuffer
                        ? new Uint8Array(event.data)
                        : new TextEncoder().encode(event.data);
                    writeBuf.push(data);
                    if (!writeRaf) writeRaf = requestAnimationFrame(flushWrites);
                } else {
                    const termDiv = document.getElementById(`term-${panel.id}`);
                    const pre = termDiv && termDiv.querySelector('pre');
                    if (pre) {
                        const text = event.data instanceof ArrayBuffer
                            ? new TextDecoder().decode(event.data) : event.data;
                        pre.textContent += text;
                        pre.scrollTop = pre.scrollHeight;
                    }
                }
            };

            ws.onclose = () => {
                setTimeout(async () => {
                    if (!panels.find(p => p.id === panel.id)) return;
                    // Check if session is still running before reconnecting
                    try {
                        const resp = await fetch(serverUrl(panel.server, `/sessions/${panel.sessionId}`));
                        if (resp.status === 404) {
                            // Session gone — close the panel
                            closePanel(panel.id);
                            fetchAllSessions();
                            return;
                        }
                        if (resp.ok) {
                            const info = await resp.json();
                            if (info.status === 'exited' || info.status === 'killed') {
                                closePanel(panel.id);
                                fetchAllSessions();
                                return;
                            }
                        }
                    } catch (e) {
                        // Network error — try reconnecting anyway
                    }
                    connectWebSocket(panel);
                }, 2000);
            };

            ws.onerror = () => {
                setServerConnectedStatus(panel.server, false);
            };

            panel.ws = ws;
        }

        // --- Input (fallback only) ---
        function handlePanelInput(event, id) {
            if (event.key !== 'Enter') return;
            const input = event.target;
            const panel = panels.find(p => p.id === id);
            if (panel && panel.ws && panel.ws.readyState === WebSocket.OPEN) {
                panel.ws.send(input.value + '\n');
                input.value = '';
            }
        }

        // --- New Session ---
        function toggleDrawer() {
            const layout = document.getElementById('layout');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            const isMobile = window.innerWidth <= 700;

            if (isMobile) {
                sidebar.classList.toggle('open');
                document.getElementById('sidebar-overlay').classList.toggle('open');
            } else {
                layout.classList.toggle('sidebar-collapsed');
            }

            // Update chevron direction and position
            const collapsed = layout.classList.contains('sidebar-collapsed');
            const mobileOpen = sidebar.classList.contains('open');
            const isOpen = (!isMobile && !collapsed) || (isMobile && mobileOpen);
            toggle.innerHTML = isOpen ? '&#x2039;' : '&#x203a;';
            toggle.classList.toggle('collapsed', !isOpen);

            // Refit terminals after sidebar transition
            setTimeout(() => panels.forEach(p => fitPanel(p)), 250);
        }

        function closeDrawer() {
            if (window.innerWidth > 700) return;
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            sidebar.classList.remove('open');
            document.getElementById('sidebar-overlay').classList.remove('open');
            toggle.innerHTML = '&#x203a;';
            toggle.classList.add('collapsed');
        }

        function openDrawer() {
            const layout = document.getElementById('layout');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            if (window.innerWidth <= 700) {
                sidebar.classList.add('open');
                document.getElementById('sidebar-overlay').classList.add('open');
            } else {
                layout.classList.remove('sidebar-collapsed');
            }
            toggle.innerHTML = '&#x2039;';
            toggle.classList.remove('collapsed');
        }

        function toggleMenu() {
            document.getElementById('hamburger-menu').classList.toggle('open');
        }

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('hamburger-menu');
            if (menu.classList.contains('open') && !e.target.closest('.menu-wrapper')) {
                menu.classList.remove('open');
            }
        });

        function toggleAbout() {
            document.getElementById('about-dialog').classList.toggle('open');
        }

        function isLocalhost() {
            const h = location.hostname;
            return h === 'localhost' || h === '127.0.0.1' || h === '::1' || h === '0.0.0.0';
        }

        // ── Settings dialog (localhost-only) ──────────────────────────────

        let _settingsData = null;  // loaded from /admin/settings

        // Show settings menu item only on localhost
        if (isLocalhost()) {
            const mi = document.getElementById('settings-menu-item');
            if (mi) mi.style.display = '';
        }

        async function toggleSettingsDialog() {
            const dialog = document.getElementById('settings-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                await loadSettings();
            }
        }

        async function loadSettings() {
            const el = document.getElementById('settings-content');
            el.innerHTML = '<div style="color:#7878a0;font-size:13px;padding:8px 0;">Loading...</div>';
            try {
                const resp = await fetch('/admin/settings');
                if (resp.status === 403) {
                    el.innerHTML = '<div style="color:#ff6060;font-size:13px;">Settings are only available from localhost.</div>';
                    return;
                }
                _settingsData = await resp.json();
                renderSettings();
            } catch (e) {
                el.innerHTML = '<div style="color:#ff6060;font-size:13px;">Failed to load settings.</div>';
            }
        }

        function renderSettings() {
            const el = document.getElementById('settings-content');
            const d = _settingsData;
            if (!d) return;

            let html = '';

            // ── Commands section
            html += '<div class="settings-section"><div class="settings-section-title">Allowed Commands</div>';
            html += '<div id="settings-commands">';
            (d.allowed_commands || []).forEach((cmd, i) => {
                html += `<div class="settings-cmd-row" data-idx="${i}">`;
                html += `<span class="cmd-label">${escHtml(cmd.label || '')}</span>`;
                html += `<span class="cmd-command">${escHtml(cmd.command || '')}</span>`;
                html += `<span class="cmd-actions">`;
                html += `<button onclick="editCommand(${i})" title="Edit">&#9998;</button>`;
                html += `<button onclick="removeCommand(${i})" title="Remove">&times;</button>`;
                html += `</span></div>`;
            });
            html += '</div>';
            html += '<button class="settings-add-btn" onclick="addCommand()">+ Add command</button>';
            html += '</div>';

            // ── Command edit form (hidden by default)
            html += '<div id="settings-cmd-edit" style="display:none"></div>';

            // ── Directories section
            html += '<div class="settings-section"><div class="settings-section-title">Default Directories</div>';
            html += '<div id="settings-dirs">';
            (d.default_directories || []).forEach((dir, i) => {
                html += `<div class="settings-dir-row">`;
                html += `<input class="settings-input" value="${escHtml(dir)}" onchange="updateDir(${i}, this.value)">`;
                html += `<button onclick="removeDir(${i})" title="Remove">&times;</button>`;
                html += `</div>`;
            });
            html += '</div>';
            html += '<button class="settings-add-btn" onclick="addDir()">+ Add directory</button>';
            html += '</div>';

            // ── Limits section
            html += '<div class="settings-section"><div class="settings-section-title">Limits</div>';
            html += '<div class="settings-row"><label>Buffer size (MB)</label>';
            html += `<input type="number" min="1" max="100" value="${Math.round((d.buffer_max_bytes || 1000000) / (1024*1024))}" onchange="_settingsData.buffer_max_bytes = Math.round(this.value * 1024 * 1024)">`;
            html += '</div>';
            html += '<div class="settings-row"><label>Max upload (MB)</label>';
            html += `<input type="number" min="1" max="500" value="${Math.round((d.max_upload_size || 10485760) / (1024*1024))}" onchange="_settingsData.max_upload_size = Math.round(this.value * 1024 * 1024)">`;
            html += '</div>';
            html += '<div class="settings-row"><label>Stop timeout (s)</label>';
            html += `<input type="number" min="5" max="300" value="${d.graceful_stop_timeout || 30}" onchange="_settingsData.graceful_stop_timeout = parseInt(this.value)">`;
            html += '</div>';
            html += '</div>';

            // ── Info section (read-only)
            html += '<div class="settings-section"><div class="settings-section-title">Server Info</div>';
            html += `<div class="settings-info-row"><span class="info-label">Version</span><span class="info-value">${escHtml(d.version || '')}</span></div>`;
            html += `<div class="settings-info-row"><span class="info-label">Host</span><span class="info-value">${escHtml(d.host || '')}:${d.port || ''}</span></div>`;
            html += `<div class="settings-info-row"><span class="info-label">Auth token</span><span class="info-value">${d.auth_enabled ? 'Enabled' : 'Not set'}</span></div>`;
            if (!d.auth_enabled) {
                html += '<div class="settings-hint">Set <code>CONDUCTOR_TOKEN</code> in your environment or systemd service to require authentication for API access.</div>';
            }
            html += '</div>';

            el.innerHTML = html;
        }

        function editCommand(idx) {
            const cmd = _settingsData.allowed_commands[idx];
            if (!cmd) return;
            const el = document.getElementById('settings-cmd-edit');
            el.style.display = 'block';
            el.innerHTML = `
                <div class="settings-edit-form">
                    <div class="form-row"><label>Label</label><input class="settings-input" id="cmd-edit-label" value="${escHtml(cmd.label || '')}"></div>
                    <div class="form-row"><label>Command</label><input class="settings-input" id="cmd-edit-command" value="${escHtml(cmd.command || '')}"></div>
                    <div class="form-row"><label>Resume pattern</label><input class="settings-input" id="cmd-edit-resume-pattern" value="${escHtml(cmd.resume_pattern || '')}" placeholder="e.g. --resume\\s+(\\S+)"></div>
                    <div class="form-row"><label>Resume flag</label><input class="settings-input" id="cmd-edit-resume-flag" value="${escHtml(cmd.resume_flag || '')}" placeholder="e.g. --resume"></div>
                    <div class="form-row"><label>Stop sequence</label><input class="settings-input" id="cmd-edit-stop" value="${escHtml((cmd.stop_sequence || []).join(', '))}" placeholder="e.g. \\x03, /exit, \\r"></div>
                    <div class="form-actions">
                        <button class="btn-cancel" onclick="document.getElementById('settings-cmd-edit').style.display='none'">Cancel</button>
                        <button class="btn-save" onclick="saveCommand(${idx})">Apply</button>
                    </div>
                </div>`;
            document.getElementById('cmd-edit-label').focus();
        }

        function saveCommand(idx) {
            const label = document.getElementById('cmd-edit-label').value.trim();
            const command = document.getElementById('cmd-edit-command').value.trim();
            if (!label || !command) return;

            const cmd = _settingsData.allowed_commands[idx] || {};
            cmd.label = label;
            cmd.command = command;

            const rp = document.getElementById('cmd-edit-resume-pattern').value.trim();
            const rf = document.getElementById('cmd-edit-resume-flag').value.trim();
            if (rp) cmd.resume_pattern = rp; else delete cmd.resume_pattern;
            if (rf) cmd.resume_flag = rf; else delete cmd.resume_flag;

            const stopStr = document.getElementById('cmd-edit-stop').value.trim();
            if (stopStr) {
                cmd.stop_sequence = stopStr.split(',').map(s => {
                    s = s.trim();
                    // Convert escape sequences back
                    s = s.replace(/\\x([0-9a-fA-F]{2})/g, (_, h) => String.fromCharCode(parseInt(h, 16)));
                    s = s.replace(/\\r/g, '\r').replace(/\\n/g, '\n').replace(/\\t/g, '\t');
                    return s;
                });
            } else {
                delete cmd.stop_sequence;
            }

            _settingsData.allowed_commands[idx] = cmd;
            document.getElementById('settings-cmd-edit').style.display = 'none';
            renderSettings();
        }

        function addCommand() {
            _settingsData.allowed_commands.push({ command: '', label: '' });
            renderSettings();
            editCommand(_settingsData.allowed_commands.length - 1);
        }

        function removeCommand(idx) {
            _settingsData.allowed_commands.splice(idx, 1);
            renderSettings();
        }

        function updateDir(idx, value) {
            _settingsData.default_directories[idx] = value;
        }

        function addDir() {
            _settingsData.default_directories.push('');
            renderSettings();
            // Focus the last input
            const inputs = document.querySelectorAll('#settings-dirs input');
            if (inputs.length) inputs[inputs.length - 1].focus();
        }

        function removeDir(idx) {
            _settingsData.default_directories.splice(idx, 1);
            renderSettings();
        }

        async function saveSettings() {
            if (!_settingsData) return;

            // Clean up: remove empty commands and directories
            _settingsData.allowed_commands = _settingsData.allowed_commands.filter(c => c.command && c.label);
            _settingsData.default_directories = _settingsData.default_directories.filter(d => d.trim());

            try {
                const resp = await fetch('/admin/settings', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(_settingsData),
                });
                if (resp.ok) {
                    document.getElementById('settings-dialog').classList.remove('open');
                    // Trigger config re-fetch for this client
                    await _refreshConfig();
                } else {
                    const err = await resp.json().catch(() => ({}));
                    alert('Failed to save: ' + (err.detail || resp.statusText));
                }
            } catch (e) {
                alert('Failed to save settings: ' + e.message);
            }
        }

        async function resetSettings() {
            if (!confirm('Reset all settings to built-in defaults?')) return;
            try {
                const resp = await fetch('/admin/settings/reset', { method: 'POST' });
                if (resp.ok) {
                    document.getElementById('settings-dialog').classList.remove('open');
                    await _refreshConfig();
                } else {
                    const err = await resp.json().catch(() => ({}));
                    alert('Failed to reset: ' + (err.detail || resp.statusText));
                }
            } catch (e) {
                alert('Failed to reset settings: ' + e.message);
            }
        }

        // ── Config version tracking ───────────────────────────────────────

        let _lastConfigVersion = -1;

        async function _refreshConfig() {
            try {
                const resp = await fetch('/config');
                const data = await resp.json();
                if (data.config_version !== undefined) {
                    _lastConfigVersion = data.config_version;
                }
                // Update cached config and rebuild command dropdown
                _serverConfigs['local'] = data;
                if (_newSessionServer === 'local') {
                    allowedCommands = data.allowed_commands || [];
                    populateCommandSelect();
                }
            } catch (e) {}
        }

        async function toggleQR() {
            const dialog = document.getElementById('qr-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                const container = document.getElementById('qr-content');
                container.innerHTML = '<p style="font-size:12px;color:#7878a0;">Loading...</p>';

                // Determine the best reachable URL for other devices
                let url = window.location.href;
                if (isLocalhost()) {
                    // On localhost — ask the server for its Tailscale IP
                    try {
                        const resp = await fetch('/info');
                        const info = await resp.json();
                        if (info.tailscale_name) {
                            url = `http://${info.tailscale_name}:${info.port}`;
                        } else if (info.tailscale_ip) {
                            url = `http://${info.tailscale_ip}:${info.port}`;
                        } else {
                            container.innerHTML = `
                                <div style="padding:16px 8px;">
                                    <div style="font-size:28px;margin-bottom:10px;">&#9888;</div>
                                    <p style="font-size:13px;color:#ff9944;margin:0 0 8px;">No reachable address found</p>
                                    <p style="font-size:12px;color:#9898b0;margin:0;line-height:1.5;">
                                        Install Tailscale to make this server reachable from other devices.
                                    </p>
                                </div>`;
                            return;
                        }
                    } catch (e) {
                        container.innerHTML = '<p style="color:#ff6666;font-size:12px;">Could not fetch server info</p>';
                        return;
                    }
                }

                container.innerHTML = `
                    <p style="font-size:12px;color:#9898b0;margin-bottom:14px;">Scan to open on another device</p>
                    <canvas id="qr-canvas" style="margin:0 auto 12px;display:block;border-radius:6px;"></canvas>
                    <p style="font-size:11px;color:#7878a0;word-break:break-all;margin:0;"></p>`;
                container.querySelector('p:last-child').textContent = url;
                try {
                    const qr = qrcode(0, 'M');
                    qr.addData(url);
                    qr.make();
                    const count = qr.getModuleCount();
                    const scale = 6;
                    const margin = 4;
                    const size = count * scale + margin * 2 * scale;
                    const canvas = document.getElementById('qr-canvas');
                    canvas.width = size;
                    canvas.height = size;
                    canvas.style.width = '200px';
                    canvas.style.height = '200px';
                    canvas.style.imageRendering = 'pixelated';
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, size, size);
                    ctx.fillStyle = '#000000';
                    for (let r = 0; r < count; r++) {
                        for (let c = 0; c < count; c++) {
                            if (qr.isDark(r, c)) {
                                ctx.fillRect((c + margin) * scale, (r + margin) * scale, scale, scale);
                            }
                        }
                    }
                } catch (e) {
                    document.getElementById('qr-canvas').parentElement.innerHTML = '<p style="color:#ff6666;font-size:12px;">Failed to generate QR code</p>';
                }
            }
        }

        // --- Server Management Dialog ---
        async function toggleServersDialog() {
            const dialog = document.getElementById('servers-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                renderServersDialog();
                await fetchSelfInfo();   // sets PORT before peer URLs are built
                fetchTailscalePeers();
            } else {
                stopQRScanner();
            }
        }

        async function fetchSelfInfo() {
            const el = document.getElementById('server-self-info');
            try {
                const resp = await fetch('/info');
                const info = await resp.json();
                if (info.port) PORT = info.port;

                // Populate version from server (single source: pyproject.toml)
                if (info.version) {
                    const vEl = document.querySelector('.about-version');
                    if (vEl) vEl.textContent = 'v' + info.version;
                    const svEl = document.getElementById('sidebar-version');
                    if (svEl) svEl.textContent = 'v' + info.version;
                }

                // Update local server label to real hostname
                if (info.hostname) {
                    const local = servers.find(s => s.key === 'local');
                    if (local) {
                        local.label = info.hostname;
                        saveServers();
                        renderSessionList();
                    }
                }

                let html = '<div style="margin-bottom:4px;font-weight:500;color:#a0a0d0;">This server</div>';
                html += `<div>Hostname: ${escHtml(info.hostname)}</div>`;
                if (info.tailscale_name) {
                    html += `<div>MagicDNS: <span class="self-url">${escHtml(info.tailscale_name)}:${escHtml(String(info.port))}</span></div>`;
                }
                if (info.tailscale_ip) {
                    html += `<div>Tailscale: <span class="self-url">${escHtml(info.tailscale_ip)}:${escHtml(String(info.port))}</span></div>`;
                }
                if (!info.tailscale_ip && !info.tailscale_name) {
                    html += `<div>Port: ${escHtml(String(info.port))}</div>`;
                }
                el.innerHTML = html;
            } catch (e) {
                el.innerHTML = '<div style="color:#7878a0;">Could not fetch server info</div>';
            }
        }

        async function fetchTailscalePeers() {
            const content = document.getElementById('tailscale-picker-content');
            if (!content) return;
            try {
                const resp = await fetch('/tailscale/peers');
                const peers = await resp.json();
                if (!peers || peers.length === 0) {
                    content.innerHTML = '<div style="font-size:12px;color:#505070;padding:4px 0;">No Tailscale peers found</div>';
                    return;
                }
                // Filter out peers already added as servers
                const existingKeys = new Set(servers.map(s => s.key));
                const available = peers.filter(p => {
                    const key = p.ip + ':' + PORT;
                    const dnsKey = p.dns_name ? p.dns_name + ':' + PORT : null;
                    return !existingKeys.has(key) && (!dnsKey || !existingKeys.has(dnsKey));
                });
                if (available.length === 0) {
                    content.innerHTML = '<div style="font-size:12px;color:#505070;padding:4px 0;">All Tailscale peers already added</div>';
                    return;
                }
                content.innerHTML = `
                    <div style="display:flex;gap:6px;">
                        <select id="tailscale-select" style="flex:1;padding:7px 10px;background:#0a0a1a;border:1px solid #2a2a5a;color:#e0e0e0;border-radius:5px;font-size:13px;">
                            ${available.map(p => {
                                const label = p.hostname || p.dns_name || p.ip;
                                const host = p.dns_name || p.ip;
                                const url = 'http://' + host + ':' + PORT;
                                const dot = p.online ? '\u25CF' : '\u25CB';
                                const dotColor = p.online ? '#44dd77' : '#505070';
                                return `<option value="${escHtml(url)}" data-label="${escHtml(label)}" data-online="${p.online ? '1' : ''}" style="color:${p.online ? '#e0e0e0' : '#707090'}">${dot} ${escHtml(p.hostname)} (${escHtml(p.ip)})</option>`;
                            }).join('')}
                        </select>
                        <button onclick="addTailscaleDevice()" style="padding:7px 14px;background:#2a2a6a;border:1px solid #3a3aaa;color:#e0e0e0;border-radius:5px;cursor:pointer;font-size:13px;white-space:nowrap;">Add</button>
                    </div>`;
            } catch (e) {
                content.innerHTML = '<div style="font-size:12px;color:#505070;padding:4px 0;">Tailscale not available</div>';
            }
        }

        // Port used when constructing URLs for Tailscale peers (updated from /info)
        let PORT = 7777;

        async function addTailscaleDevice() {
            const sel = document.getElementById('tailscale-select');
            const url = sel.value;
            if (!url) return;
            const label = sel.options[sel.selectedIndex].dataset.label || url;
            const isOnline = sel.options[sel.selectedIndex].dataset.online === '1';

            if (isOnline) {
                // Probe online devices to confirm and get server info
                const info = await probeServer(url);
                if (info) {
                    const finalLabel = info.hostname || info.tailscale_name || label;
                    const finalUrl = info.tailscale_name
                        ? 'http://' + info.tailscale_name + ':' + (info.port || PORT)
                        : info.url;
                    const server = addServer(finalUrl, finalLabel);
                    if (server) {
                        renderServersDialog();
                        updateServerSelectorVisibility();
                        fetchConfig(server.key);
                        fetchAllSessions();
                    }
                } else {
                    // Probe failed — add with URL as-is
                    addServer(url, label);
                    renderServersDialog();
                    updateServerSelectorVisibility();
                    fetchAllSessions();
                }
            } else {
                // Offline device — skip probe, add directly
                addServer(url, label);
                renderServersDialog();
                updateServerSelectorVisibility();
                fetchAllSessions();
            }
            // Refresh the dropdown to remove the added device
            fetchTailscalePeers();
        }

        function renderServersDialog() {
            const list = document.getElementById('servers-list');
            list.innerHTML = servers.map(s => {
                const connected = serverConnected[s.key] !== false;
                const dotClass = connected ? 'connected' : 'disconnected';
                const removeBtn = s.key !== 'local' ?
                    `<button onclick="removeServer('${s.key.replace(/'/g, "\\'")}');renderServersDialog();fetchTailscalePeers()" title="Remove">&times;</button>` : '';
                const urlText = s.url || '(local)';
                return `<div class="server-list-item">
                    <span class="server-dot ${dotClass}"></span>
                    <div class="server-info">
                        <div class="server-label">${escHtml(s.label)}</div>
                        <div class="server-url-text">${escHtml(urlText)}</div>
                    </div>
                    ${removeBtn}
                </div>`;
            }).join('');
        }

        async function probeServer(url) {
            url = url.replace(/\/+$/, '');
            if (!/^https?:\/\//.test(url)) url = 'http://' + url;
            try {
                const resp = await fetch(url + '/info', { signal: AbortSignal.timeout(5000) });
                if (!resp.ok) return null;
                const info = await resp.json();
                return { url, hostname: info.hostname, port: info.port, tailscale_name: info.tailscale_name };
            } catch (e) {
                return null;
            }
        }

        async function addServerFromInput() {
            const input = document.getElementById('server-url-input');
            const url = input.value.trim();
            if (!url) return;

            // Probe the server first
            const info = await probeServer(url);
            if (!info) {
                input.style.borderColor = '#ff6666';
                setTimeout(() => { input.style.borderColor = '#2a2a5a'; }, 2000);
                return;
            }

            const label = info.hostname || info.tailscale_name || url.replace(/^https?:\/\//, '');
            // Prefer MagicDNS name for stable URL even if Tailscale IP changes
            const finalUrl = info.tailscale_name
                ? 'http://' + info.tailscale_name + ':' + (info.port || PORT)
                : info.url;
            const server = addServer(finalUrl, label);
            if (!server) {
                // Already exists
                input.value = '';
                return;
            }

            input.value = '';
            renderServersDialog();
            updateServerSelectorVisibility();
            // Fetch config and sessions for the new server
            fetchConfig(server.key);
            fetchAllSessions();
        }

        // --- QR Scanner ---
        let _qrScannerStream = null;
        let _qrScannerAnimFrame = null;

        function toggleQRScanner() {
            if (_qrScannerStream) {
                stopQRScanner();
            } else {
                startQRScanner();
            }
        }

        async function startQRScanner() {
            const area = document.getElementById('qr-scanner-area');
            if (typeof jsQR === 'undefined') {
                area.innerHTML = '<div style="padding:8px;font-size:12px;color:#ff6666;">QR scanner not available. Paste the URL manually.</div>';
                return;
            }

            // Camera requires HTTPS (secure context) — plain HTTP only works on localhost
            if (!window.isSecureContext) {
                area.innerHTML = `<div style="padding:10px;font-size:12px;color:#ff9944;line-height:1.5;">
                    Camera requires HTTPS.<br>
                    Use the Tailscale device picker above, or paste the URL manually.
                </div>`;
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                area.innerHTML = '<div style="padding:8px;font-size:12px;color:#ff9944;">Camera not available on this device. Paste the URL manually.</div>';
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                _qrScannerStream = stream;

                area.innerHTML = `
                    <div class="qr-scanner-container">
                        <video id="qr-video" autoplay playsinline></video>
                        <canvas id="qr-scan-canvas"></canvas>
                    </div>
                    <div class="qr-scanner-actions">
                        <button class="stop-btn" onclick="stopQRScanner()">Stop Scanner</button>
                    </div>
                    <div class="qr-scanner-status" id="qr-scan-status">Point camera at a Conductor QR code...</div>`;

                const video = document.getElementById('qr-video');
                video.srcObject = stream;
                video.play();

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.getElementById('qr-scan-canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    scanQRFrame(video, canvas, ctx);
                });
            } catch (e) {
                area.innerHTML = `<div style="padding:8px;font-size:12px;color:#ff9944;">
                    Camera access denied or unavailable.<br>Paste the server URL manually above.
                </div>`;
            }
        }

        function scanQRFrame(video, canvas, ctx) {
            if (!_qrScannerStream) return;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: 'dontInvert',
                });

                if (code && code.data) {
                    const url = code.data.trim();
                    // Validate it looks like a Conductor URL
                    if (/^https?:\/\/.+:\d+/.test(url) || /^https?:\/\/[^/]+$/.test(url)) {
                        const status = document.getElementById('qr-scan-status');
                        if (status) status.textContent = 'Found: ' + url;
                        stopQRScanner();
                        // Auto-add the server
                        handleScannedUrl(url);
                        return;
                    }
                }
            }

            _qrScannerAnimFrame = requestAnimationFrame(() => scanQRFrame(video, canvas, ctx));
        }

        async function handleScannedUrl(url) {
            const info = await probeServer(url);
            if (!info) {
                const area = document.getElementById('qr-scanner-area');
                area.innerHTML = `<div style="padding:8px;font-size:12px;color:#ff9944;">
                    Could not connect to ${escHtml(url)}. Make sure the server is running.
                </div>`;
                return;
            }

            const label = info.hostname || info.tailscale_name || url.replace(/^https?:\/\//, '');
            // Prefer MagicDNS name for stable URL even if Tailscale IP changes
            const finalUrl = info.tailscale_name
                ? 'http://' + info.tailscale_name + ':' + (info.port || PORT)
                : info.url;
            const server = addServer(finalUrl, label);
            if (server) {
                renderServersDialog();
                updateServerSelectorVisibility();
                fetchConfig(server.key);
                fetchAllSessions();
            }
            const area = document.getElementById('qr-scanner-area');
            area.innerHTML = `<div style="padding:8px;font-size:12px;color:#44dd77;">
                Added: ${escHtml(label)}
            </div>`;
        }

        function stopQRScanner() {
            if (_qrScannerAnimFrame) {
                cancelAnimationFrame(_qrScannerAnimFrame);
                _qrScannerAnimFrame = null;
            }
            if (_qrScannerStream) {
                _qrScannerStream.getTracks().forEach(t => t.stop());
                _qrScannerStream = null;
            }
            const area = document.getElementById('qr-scanner-area');
            if (area) area.innerHTML = '';
        }

        // --- New Session Server Selector ---
        function updateServerSelectorVisibility() {
            const row = document.getElementById('server-selector-row');
            const sel = document.getElementById('new-session-server');
            if (_isMultiServer()) {
                row.style.display = 'block';
                sel.innerHTML = servers.filter(s => s.enabled).map(s => {
                    const offline = serverConnected[s.key] === false;
                    const label = offline ? `${s.label} (offline)` : s.label;
                    return `<option value="${escHtml(s.key)}" ${offline ? 'disabled' : ''}>${escHtml(label)}</option>`;
                }).join('');
                // If current selection is offline, switch to first online server
                const current = servers.find(s => s.key === _newSessionServer);
                if (current && serverConnected[current.key] === false) {
                    const online = servers.find(s => s.enabled && serverConnected[s.key] !== false);
                    if (online) _newSessionServer = online.key;
                }
                sel.value = _newSessionServer;
            } else {
                row.style.display = 'none';
                _newSessionServer = 'local';
            }
        }

        function onNewSessionServerChange() {
            const sel = document.getElementById('new-session-server');
            _newSessionServer = sel.value;
            // Load config from selected server
            const cached = _serverConfigs[_newSessionServer];
            if (cached) {
                allowedCommands = cached.allowed_commands || [];
                populateCommandSelect();
                browseTo('~', _newSessionServer);
            } else {
                fetchConfig(_newSessionServer);
            }
        }

        const _SAFE_NAME_RE = /^[a-zA-Z0-9][a-zA-Z0-9 _.~-]{0,63}$/;

        function validateNewSession() {
            const name = document.getElementById('new-name').value.trim();
            const nameInput = document.getElementById('new-name');
            const nameError = document.getElementById('name-error');
            const btn = document.getElementById('run-btn');
            // Check name against sessions on the target server
            const serverSessions = sessions.filter(s => s._server === _newSessionServer);
            const nameTaken = name && serverSessions.some(s => s.name === name);
            const nameInvalid = name && !_SAFE_NAME_RE.test(name);
            nameError.textContent = nameTaken ? 'Name already taken' : nameInvalid ? 'Only letters, numbers, hyphens, underscores' : '';
            nameError.style.display = (nameTaken || nameInvalid) ? 'block' : 'none';
            nameInput.style.borderColor = (nameTaken || nameInvalid) ? '#ff6666' : '#2a2a5a';
            btn.disabled = !name || nameTaken || nameInvalid || !selectedCwd;
        }

        function toggleNewSession() {
            const dialog = document.getElementById('new-session-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                updateServerSelectorVisibility();
                document.getElementById('new-name').focus();
                validateNewSession();
            }
        }

        async function createSession() {
            const name = document.getElementById('new-name').value.trim();
            const command = document.getElementById('new-command').value;
            const cwd = selectedCwd || null;
            if (!name || !command) return;

            try {
                const resp = await fetch(serverUrl(_newSessionServer, '/sessions/run'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, command, cwd }),
                });
                if (resp.ok) {
                    document.getElementById('new-name').value = '';
                    document.getElementById('new-session-dialog').classList.remove('open');
                    await fetchAllSessions();
                    const cid = compoundId(_newSessionServer, name);
                    closeDrawer();
                    openSession(cid, name);
                } else {
                    const err = await resp.json();
                    alert(err.detail || 'Failed to create session');
                }
            } catch (e) {
                alert('Server unreachable');
            }
        }

        function showConfirm(message) {
            return new Promise(resolve => {
                const overlay = document.getElementById('confirm-dialog');
                document.getElementById('confirm-msg').textContent = message;
                overlay.classList.add('open');
                const yes = document.getElementById('confirm-yes');
                const no = document.getElementById('confirm-no');
                function cleanup(result) {
                    overlay.classList.remove('open');
                    yes.replaceWith(yes.cloneNode(true));
                    no.replaceWith(no.cloneNode(true));
                    resolve(result);
                }
                yes.addEventListener('click', () => cleanup(true), { once: true });
                no.addEventListener('click', () => cleanup(false), { once: true });
                overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(false); }, { once: true });
            });
        }

        function showStopDialog(message) {
            return new Promise(resolve => {
                const overlay = document.getElementById('stop-dialog');
                document.getElementById('stop-msg').textContent = message;
                overlay.classList.add('open');
                const graceful = document.getElementById('stop-graceful-btn');
                const kill = document.getElementById('stop-kill-btn');
                const cancel = document.getElementById('stop-cancel-btn');
                function cleanup(result) {
                    overlay.classList.remove('open');
                    graceful.replaceWith(graceful.cloneNode(true));
                    kill.replaceWith(kill.cloneNode(true));
                    cancel.replaceWith(cancel.cloneNode(true));
                    resolve(result);
                }
                graceful.addEventListener('click', () => cleanup('graceful'), { once: true });
                kill.addEventListener('click', () => cleanup('kill'), { once: true });
                cancel.addEventListener('click', () => cleanup(null), { once: true });
                overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(null); }, { once: true });
            });
        }

        async function killSession(cid) {
            const { server, sessionId } = parseCompoundId(cid);
            const session = sessions.find(s => s._compoundId === cid);
            const label = session ? session.name : 'this session';
            const choice = await showStopDialog(`Stop "${label}"?`);
            if (!choice) return;
            try {
                if (choice === 'graceful') {
                    await fetch(serverUrl(server, `/sessions/${sessionId}/stop`), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ mode: 'graceful' }),
                    });
                    // Keep the panel open so the user sees the shutdown.
                    // ws.onclose will close it when the session actually exits.
                } else {
                    await fetch(serverUrl(server, `/sessions/${sessionId}`), { method: 'DELETE' });
                    closePanel(cid);
                }
                await fetchAllSessions();
            } catch (e) {}
        }

        let _resumingSession = null;  // guard against double-click
        async function resumeSession(cid) {
            if (_resumingSession === cid) return;
            _resumingSession = cid;
            renderSessionList();  // show spinner immediately
            const { server, sessionId } = parseCompoundId(cid);
            try {
                const resp = await fetch(serverUrl(server, `/sessions/${sessionId}/resume`), { method: 'POST' });
                if (resp.ok) {
                    await fetchAllSessions();
                    closeDrawer();
                    openSession(cid, sessionId);
                } else {
                    const err = await resp.json();
                    alert(err.detail || 'Failed to resume session');
                }
            } catch (e) {
                alert('Server unreachable');
            } finally {
                _resumingSession = null;
                renderSessionList();
            }
        }

        async function dismissSession(cid) {
            const { server, sessionId } = parseCompoundId(cid);
            const session = sessions.find(s => s._compoundId === cid);
            const label = session ? session.name : 'this session';
            if (!await showConfirm(`Dismiss "${label}"? The resume token will be lost.`)) return;
            try {
                await fetch(serverUrl(server, `/sessions/${sessionId}`), { method: 'DELETE' });
                await fetchAllSessions();
            } catch (e) {}
        }

        // --- Window / viewport resize ---
        window.addEventListener('resize', debounce(() => {
            panels.forEach(p => fitPanel(p));
        }, 150));
        // On mobile, visualViewport resize fires when the address bar
        // hides/shows or the keyboard opens — the layout viewport stays
        // unchanged so window.resize doesn't fire.
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', debounce(() => {
                panels.forEach(p => fitPanel(p));
            }, 200));
        }

        // --- Notifications ---
        // Detect when a session needs attention by scanning terminal output.
        // Two triggers: (1) permission/question prompts, (2) long idle after sustained activity.
        let notificationsEnabled = false;

        async function requestNotificationPermission() {
            if (!('Notification' in window)) return false;
            if (Notification.permission === 'granted') return true;
            if (Notification.permission === 'denied') return false;
            const result = await Notification.requestPermission();
            return result === 'granted';
        }

        function sendNotification(title, body) {
            if (!notificationsEnabled) return;
            if (document.visibilityState === 'visible') return;
            try {
                new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="80" font-size="80">♭</text></svg>',
                    tag: 'conductor-' + title,
                });
            } catch (e) {}
        }

        // Read the last N non-empty lines from the xterm buffer
        function getTerminalTail(panel, count) {
            if (!panel.terminal) return '';
            const buf = panel.terminal.buffer.active;
            const lines = [];
            for (let i = buf.length - 1; i >= 0 && lines.length < count; i--) {
                const line = buf.getLine(i);
                if (line) {
                    const text = line.translateToString(true).trim();
                    if (text) lines.unshift(text);
                }
            }
            return lines.join('\n');
        }

        const _activityTimers = {};
        const _outputBytes = {};     // track output volume per panel
        const _lastNotified = {};    // prevent duplicate notifications
        function trackActivity(panel) {
            if (_activityTimers[panel.id]) clearTimeout(_activityTimers[panel.id]);

            // Count output chunks — we only notify after sustained activity
            _outputBytes[panel.id] = (_outputBytes[panel.id] || 0) + 1;

            _activityTimers[panel.id] = setTimeout(() => {
                // Need real output before we consider notifying
                const volume = _outputBytes[panel.id] || 0;
                _outputBytes[panel.id] = 0;
                if (volume < 10) return; // ignore tiny bursts (keepalives, cursor moves)

                const tail = getTerminalTail(panel, 8);
                if (!tail) return;

                let reason = null;
                // Permission / confirmation prompts
                if (/\(y\)es.*\(n\)o/i.test(tail) || /\[Y\/n\]/i.test(tail) || /\(y\/n\)/i.test(tail)) {
                    reason = 'Needs confirmation';
                } else if (/allow|deny|approve|reject/i.test(tail) && /\?/m.test(tail)) {
                    reason = 'Asking for permission';
                // Question being asked
                } else if (/\?\s*$/m.test(tail)) {
                    reason = 'Asking a question';
                // Long idle after lots of output = task likely finished
                } else if (volume > 100) {
                    reason = 'Task may be complete';
                }

                if (!reason) return;
                // Don't re-notify the same thing
                const key = panel.id + ':' + reason;
                if (_lastNotified[key]) return;
                _lastNotified[key] = true;
                // Clear after 60s so we can notify again for a new occurrence
                setTimeout(() => { delete _lastNotified[key]; }, 60000);

                sendNotification(`♭ ${panel.name}`, reason);
            }, 5000); // 5s of silence before checking
        }

        // --- Init ---
        // Load server registry from localStorage
        loadServers();

        // On mobile, open the sidebar drawer on load
        if (window.innerWidth <= 700) {
            document.getElementById('sidebar').classList.add('open');
        }

        // Request notification permission on first user interaction
        document.addEventListener('click', async function initNotif() {
            notificationsEnabled = await requestNotificationPermission();
            document.removeEventListener('click', initNotif);
        }, { once: true });

        document.getElementById('new-name').addEventListener('input', validateNewSession);

        // Fetch local server info (hostname) and config for all enabled servers
        fetchSelfInfo();
        servers.filter(s => s.enabled).forEach(s => fetchConfig(s.key));

        // Start polling sessions from all servers
        fetchAllSessions();
        setInterval(fetchAllSessions, 1500);

        // --- Update check ---
        function _semverNewer(a, b) {
            const pa = a.split('.').map(Number);
            const pb = b.split('.').map(Number);
            for (let i = 0; i < 3; i++) {
                if ((pa[i] || 0) > (pb[i] || 0)) return true;
                if ((pa[i] || 0) < (pb[i] || 0)) return false;
            }
            return false;
        }

        function checkForUpdate() {
            const cur = document.querySelector('.about-version')
                ?.textContent?.trim()?.replace(/^v/, '');
            if (!cur) return;

            // Use cached result if available (avoids GitHub rate limits)
            const cached = sessionStorage.getItem('_updateRelease');
            if (cached) {
                try {
                    const c = JSON.parse(cached);
                    if (c.version && c.url && _semverNewer(c.version, cur)) {
                        _showUpdateBanner(c.version, c.url);
                    }
                } catch (e) {}
                return;
            }

            fetch('https://api.github.com/repos/somniacs/conductor/releases/latest')
                .then(r => r.ok ? r.json() : null)
                .then(data => {
                    if (!data || !data.tag_name) return;
                    const latest = data.tag_name.replace(/^v/, '');
                    sessionStorage.setItem('_updateRelease',
                        JSON.stringify({ version: latest, url: data.html_url }));
                    if (_semverNewer(latest, cur)) {
                        _showUpdateBanner(latest, data.html_url);
                    }
                })
                .catch(() => {});
        }

        function _showUpdateBanner(version, url) {
            const el = document.getElementById('update-status');
            if (el) {
                el.textContent = '\u2191 v' + version + ' available';
                el.href = url;
                el.style.display = 'block';
            }
        }

        setTimeout(checkForUpdate, 5000);
    </script>
</body>
</html>
