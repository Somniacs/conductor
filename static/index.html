<!--
  conductor — Local orchestration for terminal sessions.

  Copyright (c) 2026 Max Rheiner / Somniacs AG

  Licensed under the MIT License. You may obtain a copy
  of the license at:

      https://opensource.org/licenses/MIT

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND.

  Dashboard — single-file web UI with multi-server support,
  split-pane xterm.js terminals, and QR-based server pairing.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>conductor</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>♭</text></svg>">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: #0a0a1a;
            color: #e0e0e0;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        .layout {
            display: flex;
            height: 100vh;
            height: 100dvh;
        }

        /* Sidebar */
        .sidebar {
            background: #10102a;
            border-right: 1px solid #1e1e3e;
            display: flex;
            flex-direction: column;
            overflow: visible;
            width: 210px;
            min-width: 210px;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px 16px 12px;
            border-bottom: 1px solid #1e1e3e;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .sidebar-header h1 {
            font-size: 17px;
            font-weight: 600;
            color: #8080ff;
            letter-spacing: 0.5px;
        }

        .sidebar-actions {
            padding: 12px;
            border-bottom: 1px solid #1e1e3e;
            display: flex;
            gap: 6px;
        }

        .sidebar-actions button {
            flex: 1;
            padding: 7px 10px;
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            color: #c0c0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .sidebar-actions button:hover { background: #242450; }

        .server-status {
            display: none;
            padding: 8px 12px;
            background: #3a1a1a;
            border-bottom: 1px solid #5a2a2a;
            color: #ff6060;
            font-size: 11px;
            text-align: center;
        }
        .server-status.disconnected { display: block; }

        #session-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .session-item {
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            transition: background 0.15s;
        }

        .session-item:hover { background: #1a1a3e; }
        .session-item.open {
            background: #151535;
            padding-left: 10px;
            border-left: 2px solid #404080;
        }
        .session-item.focused {
            background: #252560;
            padding-left: 10px;
            border-left: 2px solid #8080ee;
        }

        .session-name {
            font-weight: 400;
            overflow: hidden;
            min-width: 0;
            flex: 1;
        }

        .session-name > div:first-child {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .session-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .session-status.running { color: #44dd77; background: #113322; }
        .session-status.exited  { color: #ff6666; background: #331111; }
        .session-status.killed  { color: #ff9944; background: #332211; }

        .session-actions { display: flex; gap: 4px; margin-left: 6px; }
        .session-actions button {
            background: none; border: none; color: #666;
            cursor: pointer; font-size: 14px; padding: 2px 4px; border-radius: 3px;
        }
        .session-actions button:hover { color: #ff6666; background: #331111; }

        /* Server group headers in sidebar */
        .server-group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px 4px;
            font-size: 11px;
            color: #606080;
            letter-spacing: 0.3px;
        }
        .server-group-header:first-child { padding-top: 4px; }
        .server-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .server-dot.connected { background: #44dd77; }
        .server-dot.disconnected { background: #ff4444; }

        /* New session dialog */
        .new-session {
            padding: 12px;
            border-top: 1px solid #1e1e3e;
            display: none;
        }

        .new-session.open { display: block; }

        .new-session label {
            display: block;
            font-size: 11px;
            color: #808090;
            margin-bottom: 3px;
            margin-top: 8px;
        }

        .new-session label:first-child { margin-top: 0; }

        .new-session input, .new-session select {
            width: 100%;
            padding: 7px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
        }

        .new-session select option { background: #0a0a1a; }

        .new-session .run-btn {
            width: 100%;
            padding: 7px;
            margin-top: 10px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }

        .new-session .run-btn:disabled { background: #1a1a3a; border-color: #2a2a4a; color: #505070; cursor: not-allowed; }
        .new-session .run-btn:hover:not(:disabled) { background: #3a3a7a; }

        /* Confirm dialog */
        .confirm-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .confirm-overlay.open { display: flex; }
        .confirm-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 20px 24px;
            min-width: 280px;
            max-width: 360px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        .confirm-box p {
            margin: 0 0 16px;
            color: #d0d0e0;
            font-size: 14px;
            line-height: 1.4;
        }
        .confirm-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .confirm-actions button {
            padding: 6px 16px;
            border-radius: 5px;
            border: 1px solid #2a2a5a;
            cursor: pointer;
            font-size: 13px;
        }
        .confirm-cancel {
            background: transparent;
            color: #a0a0b0;
        }
        .confirm-cancel:hover { background: #1e1e3e; }
        .confirm-ok {
            background: #7a2a2a;
            border-color: #aa3a3a;
            color: #f0d0d0;
        }
        .confirm-ok:hover { background: #8a3a3a; }

        /* About modal */
        .about-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .about-overlay.open { display: flex; }
        .about-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 24px 28px;
            min-width: 300px;
            max-width: 420px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
        }
        .about-box h2 {
            font-size: 18px;
            color: #8080ff;
            margin: 0 0 4px;
            font-weight: 600;
        }
        .about-box .about-version {
            font-size: 11px;
            color: #606080;
            margin-bottom: 14px;
        }
        .about-box p {
            font-size: 13px;
            color: #b0b0c0;
            line-height: 1.5;
            margin: 0 0 12px;
        }
        .about-box a {
            color: #7070cc;
            text-decoration: none;
        }
        .about-box a:hover { text-decoration: underline; }
        .about-box .about-section {
            font-size: 11px;
            color: #606080;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 14px 0 6px;
        }
        .about-box ul {
            list-style: none;
            padding: 0;
            margin: 0 0 10px;
            font-size: 12px;
            color: #a0a0b0;
        }
        .about-box ul li { padding: 2px 0; }
        .about-close {
            position: absolute;
            top: 10px;
            right: 12px;
            background: none;
            border: none;
            color: #606080;
            font-size: 18px;
            cursor: pointer;
            padding: 2px 6px;
            line-height: 1;
        }
        .about-close:hover { color: #c0c0e0; }
        .menu-btn {
            background: none;
            border: none;
            color: #606080;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .menu-btn:hover { color: #a0a0d0; }

        /* Hamburger dropdown */
        .menu-wrapper { position: absolute; right: 16px; }
        .menu-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            min-width: 140px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 400;
            overflow: hidden;
        }
        .menu-dropdown.open { display: block; }
        .menu-dropdown a {
            display: block;
            padding: 8px 14px;
            font-size: 13px;
            color: #c0c0e0;
            text-decoration: none;
            cursor: pointer;
        }
        .menu-dropdown a:hover { background: #1e1e4e; }
        .menu-dropdown .menu-sep {
            height: 1px;
            background: #2a2a5a;
            margin: 2px 0;
        }

        /* Directory picker */
        .dir-picker {
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            border-radius: 5px;
            margin-top: 2px;
            max-height: 200px;
            overflow-y: auto;
        }

        .dir-picker .dir-current {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid #1a1a3a;
            font-size: 12px;
            color: #8080ff;
            word-break: break-all;
        }

        .dir-picker .dir-current button {
            flex-shrink: 0;
            background: none;
            border: none;
            color: #808090;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .dir-picker .dir-current button:hover {
            background: #1a1a3e;
            color: #e0e0e0;
        }

        .dir-picker .dir-entry {
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #c0c0e0;
        }

        .dir-picker .dir-entry:hover { background: #1a1a3e; }
        .dir-picker .dir-icon { color: #6060aa; font-size: 11px; }

        .dir-picker .dir-empty {
            padding: 8px 10px;
            font-size: 11px;
            color: #505070;
        }

        /* Content area */
        .content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-width: 0;
        }

        /* Placement menu — anchored to sidebar session item */
        .placement-menu {
            display: none;
            position: absolute;
            z-index: 600;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
            padding: 4px;
            gap: 2px;
        }
        .placement-menu.open { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: auto auto auto auto auto; width: 120px; }
        .placement-menu button {
            background: #1a1a3e;
            border: 1px solid #2a2a5a;
            color: #c0c0e0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            padding: 6px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .placement-menu button:hover { background: #2a2a6a; border-color: #4a4aaa; color: #fff; }
        .placement-menu .pm-top    { grid-column: 2; grid-row: 2; }
        .placement-menu .pm-left   { grid-column: 1; grid-row: 3; }
        .placement-menu .pm-right  { grid-column: 3; grid-row: 3; }
        .placement-menu .pm-bottom { grid-column: 2; grid-row: 4; }
        .placement-menu .pm-title  { grid-column: 1 / 4; text-align: center; font-size: 11px; color: #808090; padding: 2px 0 4px; }
        .placement-menu .pm-status { grid-column: 1 / 4; text-align: center; font-size: 9px; color: #606080; padding: 2px 0 0; min-height: 14px; white-space: nowrap; }
        .placement-menu .pm-center { grid-column: 2; grid-row: 3; background: #0a0a1a; border-color: #1a1a3a; color: #808090; font-size: 14px; }
        .placement-menu .pm-center:hover { background: #1a1a3e; color: #fff; border-color: #4a4aaa; }

        /* Panels container */
        #panels {
            flex: 1;
            display: flex;
            overflow: hidden;
            background: #0a0a1a;
        }

        /* Split panes */
        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .split-container.vertical { flex-direction: column; }
        .split-container.horizontal { flex-direction: row; }

        .split-pane {
            flex: 1;
            overflow: hidden;
            display: flex;
            min-width: 100px;
            min-height: 80px;
        }

        .split-handle {
            flex-shrink: 0;
            background: #1e1e3e;
            transition: background 0.15s;
            position: relative;
        }

        .split-handle:hover, .split-handle.dragging {
            background: #4a4aaa;
        }

        .split-handle.h-handle {
            width: 5px;
            cursor: col-resize;
        }
        .split-handle.v-handle {
            height: 5px;
            cursor: row-resize;
        }

        /* Panel */
        .panel {
            display: flex;
            flex-direction: column;
            background: #12122a;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }

        .panel-header {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: #0e0e24;
            border-bottom: 1px solid #1e1e3e;
            font-size: 12px;
            min-height: 32px;
        }

        .panel-header .panel-title {
            flex: 1;
            text-align: center;
            font-weight: 500;
            color: #a0a0d0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .panel-focused .panel-header { background: #1a1a48; border-bottom: 1px solid #4040aa; }
        .panel-focused .panel-header .panel-title { color: #d0d0ff; }
        .panel-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-header button {
            background: none; border: none; color: #606080;
            cursor: pointer; font-size: 16px; padding: 4px 6px; line-height: 1;
        }
        .panel-header button:hover { color: #c0c0e0; }
        .panel-header button.close-btn:hover { color: #ff6666; }
        .panel-header .font-btn { font-size: 13px; font-weight: 600; }
        .panel-header .theme-btn { padding: 3px 6px; display: flex; align-items: center; }
        .theme-ring {
            display: inline-block;
            width: 12px; height: 12px;
            border-radius: 50%;
            border: 2px solid;
            box-sizing: border-box;
        }
        .theme-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 2px;
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 6px;
            min-width: 110px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 500;
            overflow: hidden;
        }
        .theme-menu.open { display: block; }
        .theme-menu a {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            font-size: 12px;
            color: #c0c0e0;
            text-decoration: none;
            cursor: pointer;
        }
        .theme-menu a:hover { background: #1e1e4e; }
        .theme-menu a.active { color: #8080ff; }
        .theme-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid;
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .theme-menu a.active .theme-dot {
            outline: 2px solid;
            outline-offset: 1px;
        }

        .extra-keys-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 600;
            background: #0e0e24;
            border-top: 1px solid #2a2a5a;
            user-select: none;
            -webkit-user-select: none;
            transition: transform 0.2s ease;
        }
        .extra-keys-bar.collapsed .extra-keys-rows { display: none; }
        .extra-keys-chevron {
            display: flex;
            justify-content: center;
            padding: 2px 0;
            cursor: pointer;
            color: #606080;
            font-size: 12px;
            line-height: 1;
            -webkit-tap-highlight-color: transparent;
        }
        .extra-keys-chevron:hover { color: #a0a0d0; }
        .extra-keys-rows {
            display: flex;
            padding: 3px 4px;
            gap: 2px;
            flex-wrap: wrap;
        }
        .extra-keys-rows button {
            background: #1a1a3a;
            border: 1px solid #2a2a5a;
            color: #b0b0d0;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            padding: 6px 0;
            border-radius: 4px;
            cursor: pointer;
            flex: 1;
            min-width: 0;
            text-align: center;
            line-height: 1.2;
            -webkit-tap-highlight-color: transparent;
        }
        .extra-keys-rows button:active { background: #2a2a5a; color: #e0e0ff; }
        .extra-keys-rows button.modifier-active {
            background: #3a3a7a;
            color: #ffffff;
            border-color: #5050aa;
        }

        .panel-terminal {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .terminal-wrapper {
            width: 100%;
            height: 100%;
            /* min-width is set dynamically from JS after measuring char width */
        }

        .panel-terminal pre {
            padding: 8px 12px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px; line-height: 1.4;
            white-space: pre-wrap; word-wrap: break-word;
            overflow-y: auto; height: 100%; color: #d0d0d0;
        }

        /* Thin scrollbars */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #2a2a5a; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #3a3a7a; }
        /* Firefox */
        * { scrollbar-width: thin; scrollbar-color: #2a2a5a transparent; }

        /* Fallback input bar (only shown when xterm.js unavailable) */
        .panel-input {
            padding: 6px 8px;
            border-top: 1px solid #1e1e3e;
            background: #0e0e24;
        }

        .panel-input input {
            width: 100%;
            padding: 6px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            outline: none;
        }

        .panel-input input:focus { border-color: #4a4aaa; }

        /* Empty state */
        .empty-state {
            display: flex; align-items: center; justify-content: center;
            height: 100%; width: 100%;
            color: #404060; font-size: 14px;
            flex-direction: column; gap: 8px;
        }

        .empty-state .icon { font-size: 48px; opacity: 0.3; }

        /* Sidebar chevron toggle — sticks to sidebar edge */
        .drawer-toggle {
            position: absolute;
            top: 0;
            right: -16px;
            z-index: 301;
            background: #10102a;
            border: 1px solid #2a2a5a;
            border-left: none;
            color: #8080c0;
            font-size: 14px;
            width: 16px;
            height: 36px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        .drawer-toggle:hover { color: #c0c0e0; }

        .sidebar-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 299;
        }
        .sidebar-overlay.open { display: block; }

        /* Collapsible sidebar */
        .sidebar {
            position: relative;
            transition: width 0.2s ease, min-width 0.2s ease;
        }
        .layout.sidebar-collapsed .sidebar {
            width: 0;
            min-width: 0;
            border-right: none;
        }
        .layout.sidebar-collapsed .sidebar > *:not(.drawer-toggle) {
            display: none;
        }

        @media (max-width: 700px) {
            .sidebar {
                position: fixed;
                top: 0; left: 0; bottom: 0;
                width: 260px;
                min-width: 260px;
                z-index: 300;
                transform: translateX(-100%);
                transition: transform 0.2s ease;
            }
            .sidebar.open { transform: translateX(0); }
            .layout.sidebar-collapsed .sidebar {
                width: 260px;
                min-width: 260px;
                overflow: visible;
            }
            .drawer-toggle {
                left: 260px;
                right: auto;
                width: 20px;
                border-radius: 0 6px 6px 0;
            }
        }

        /* Server management dialog */
        .servers-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .servers-overlay.open { display: flex; }
        .servers-box {
            background: #16163a;
            border: 1px solid #2a2a5a;
            border-radius: 8px;
            padding: 24px 28px;
            min-width: 340px;
            max-width: 480px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }
        .servers-box h2 {
            font-size: 16px;
            color: #8080ff;
            margin: 0 0 16px;
            font-weight: 600;
        }
        .server-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 5px;
            margin-bottom: 4px;
            background: #0e0e24;
        }
        .server-list-item .server-info {
            flex: 1;
            min-width: 0;
        }
        .server-list-item .server-label {
            font-size: 13px;
            color: #c0c0e0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .server-list-item .server-url-text {
            font-size: 11px;
            color: #606080;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .server-list-item button {
            background: none;
            border: none;
            color: #606080;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
            flex-shrink: 0;
        }
        .server-list-item button:hover { color: #ff6666; }
        .server-add-form {
            display: flex;
            gap: 6px;
            margin-top: 12px;
        }
        .server-add-form input {
            flex: 1;
            padding: 7px 10px;
            background: #0a0a1a;
            border: 1px solid #2a2a5a;
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 13px;
        }
        .server-add-form button {
            padding: 7px 14px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        .server-add-form button:hover { background: #3a3a7a; }
        .server-self-info {
            margin-top: 14px;
            padding: 10px;
            background: #0e0e24;
            border-radius: 5px;
            font-size: 12px;
            color: #808090;
        }
        .server-self-info .self-url {
            color: #8080ff;
            font-family: 'Consolas', monospace;
            user-select: all;
            cursor: text;
        }

        /* QR Scanner */
        .qr-scanner-container {
            position: relative;
            margin-top: 12px;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }
        .qr-scanner-container video {
            width: 100%;
            display: block;
        }
        .qr-scanner-container canvas { display: none; }
        .qr-scanner-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        .qr-scanner-actions button {
            padding: 7px 14px;
            background: #2a2a6a;
            border: 1px solid #3a3aaa;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
        }
        .qr-scanner-actions button:hover { background: #3a3a7a; }
        .qr-scanner-actions button.stop-btn { background: #5a2a2a; border-color: #7a3a3a; }
        .qr-scanner-actions button.stop-btn:hover { background: #6a3a3a; }
    </style>
</head>
<body>
    <div class="sidebar-overlay" id="sidebar-overlay" onclick="toggleDrawer()"></div>
    <div class="layout" id="layout">
        <aside class="sidebar" id="sidebar">
            <button class="drawer-toggle" id="drawer-toggle" onclick="toggleDrawer()">&#x2039;</button>
            <div class="sidebar-header">
                <h1><a href="https://github.com/somniacs/conductor" target="_blank" style="color:inherit;text-decoration:none"><span style="font-size:1.8em;line-height:0;vertical-align:middle">♭</span> conductor</a></h1>
                <div class="menu-wrapper">
                    <button class="menu-btn" onclick="toggleMenu()" title="Menu">&#9776;</button>
                    <div class="menu-dropdown" id="hamburger-menu">
                        <a onclick="toggleMenu();toggleServersDialog()">Servers</a>
                        <div class="menu-sep"></div>
                        <a onclick="toggleMenu();toggleQR()">Link Device</a>
                        <div class="menu-sep"></div>
                        <a href="https://github.com/somniacs/conductor/blob/master/README.md" target="_blank" onclick="toggleMenu()">Help</a>
                        <div class="menu-sep"></div>
                        <a onclick="toggleMenu();toggleAbout()">About</a>
                    </div>
                </div>
            </div>
            <div class="sidebar-actions">
                <button onclick="toggleNewSession()">+ New</button>
            </div>
            <div class="server-status" id="server-status">Server disconnected — retrying...</div>
            <div id="session-list"></div>
            <div class="new-session" id="new-session-dialog">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <span style="font-size:12px;font-weight:500;color:#a0a0d0;">New Session</span>
                    <button onclick="toggleNewSession()" style="background:none;border:none;color:#606080;cursor:pointer;font-size:16px;padding:0 2px;line-height:1;" title="Cancel">&times;</button>
                </div>
                <div id="server-selector-row" style="display:none;">
                    <label>Machine</label>
                    <select id="new-session-server" onchange="onNewSessionServerChange()"></select>
                </div>
                <label>Session name</label>
                <input type="text" id="new-name" placeholder="e.g. research" autocomplete="off">
                <div id="name-error" style="font-size:11px;color:#ff6666;margin-top:2px;display:none;">Name already taken</div>
                <label>Command</label>
                <select id="new-command"></select>
                <label>Working directory</label>
                <div class="dir-picker" id="dir-picker"></div>
                <button class="run-btn" id="run-btn" onclick="createSession()" disabled>Run</button>
            </div>
        </aside>
        <main class="content">
            <div id="panels">
                <div class="empty-state">
                    <div class="icon">&#9837;</div>
                    <div>Select a session or create a new one</div>
                </div>
            </div>
        </main>
    </div>

    <div class="placement-menu" id="placement-menu">
        <div class="pm-title">Placement</div>
        <button class="pm-top" onclick="placeSession('top')" data-hint="Place above">&#x2B06;</button>
        <button class="pm-left" onclick="placeSession('left')" data-hint="Place left">&#x2B05;</button>
        <button class="pm-center" onclick="placeSession('single')" data-hint="Single view">&#x25A3;</button>
        <button class="pm-right" onclick="placeSession('right')" data-hint="Place right">&#x27A1;</button>
        <button class="pm-bottom" onclick="placeSession('bottom')" data-hint="Place below">&#x2B07;</button>
        <div class="pm-status" id="pm-status"></div>
    </div>

    <div class="about-overlay" id="about-dialog" onclick="if(event.target===this)toggleAbout()">
        <div class="about-box">
            <button class="about-close" onclick="toggleAbout()">&times;</button>
            <h2><span style="font-size:1.4em;vertical-align:middle">♭</span> conductor</h2>
            <div class="about-version">v0.1.3</div>
            <p>Local orchestration layer for interactive terminal processes. Run sessions on your workstation, interact from anywhere.</p>
            <div class="about-section">Built with</div>
            <ul>
                <li><a href="https://fastapi.tiangolo.com" target="_blank">FastAPI</a> &mdash; async web framework</li>
                <li><a href="https://xtermjs.org" target="_blank">xterm.js</a> &mdash; terminal rendering</li>
                <li><a href="https://uvicorn.org" target="_blank">Uvicorn</a> &mdash; ASGI server</li>
                <li><a href="https://click.palletsprojects.com" target="_blank">Click</a> &mdash; CLI framework</li>
                <li><a href="https://tailscale.com" target="_blank">Tailscale</a> &mdash; secure remote access</li>
                <li><a href="https://websockets.readthedocs.io" target="_blank">websockets</a> &mdash; real-time terminal I/O</li>
                <li><a href="https://www.python-httpx.org" target="_blank">httpx</a> &mdash; HTTP client</li>
                <li><a href="https://github.com/andfoy/pywinpty" target="_blank">pywinpty</a> &mdash; Windows ConPTY support</li>
                <li><a href="https://github.com/lincolnloop/python-qrcode" target="_blank">qrcode</a> &mdash; QR device linking</li>
            </ul>
            <div class="about-section">Author</div>
            <p>Max Rheiner / Somniacs AG</p>
            <div class="about-section">License</div>
            <p><a href="https://github.com/somniacs/conductor/blob/master/LICENSE" target="_blank">MIT License</a></p>
            <div class="about-section">Source</div>
            <p style="margin-bottom:0"><a href="https://github.com/somniacs/conductor" target="_blank">github.com/somniacs/conductor</a></p>
        </div>
    </div>

    <div class="about-overlay" id="qr-dialog" onclick="if(event.target===this)toggleQR()">
        <div class="about-box" style="text-align:center;min-width:260px;">
            <button class="about-close" onclick="toggleQR()">&times;</button>
            <h2 style="font-size:16px;margin-bottom:12px;">Link Device</h2>
            <div id="qr-content"></div>
        </div>
    </div>

    <div class="servers-overlay" id="servers-dialog" onclick="if(event.target===this)toggleServersDialog()">
        <div class="servers-box">
            <button class="about-close" onclick="toggleServersDialog()">&times;</button>
            <h2>Servers</h2>
            <div id="servers-list"></div>
            <div id="tailscale-picker" style="margin-top:12px;">
                <label style="display:block;font-size:11px;color:#808090;margin-bottom:4px;">Tailscale devices</label>
                <div id="tailscale-picker-content">
                    <div style="font-size:12px;color:#505070;padding:4px 0;">Loading...</div>
                </div>
            </div>
            <div style="margin-top:10px;">
                <label style="display:block;font-size:11px;color:#808090;margin-bottom:4px;">Or add manually</label>
                <div class="server-add-form">
                    <input type="text" id="server-url-input" placeholder="http://100.x.x.x:7777" autocomplete="off"
                        onkeydown="if(event.key==='Enter')addServerFromInput()">
                    <button onclick="addServerFromInput()">Add</button>
                    <button onclick="toggleQRScanner()" id="qr-scan-btn" title="Scan QR code">&#x1F4F7;</button>
                </div>
            </div>
            <div id="qr-scanner-area"></div>
            <div class="server-self-info" id="server-self-info"></div>
        </div>
    </div>

    <div class="confirm-overlay" id="confirm-dialog">
        <div class="confirm-box">
            <p id="confirm-msg"></p>
            <div class="confirm-actions">
                <button class="confirm-cancel" id="confirm-no">Cancel</button>
                <button class="confirm-ok" id="confirm-yes">Stop</button>
            </div>
        </div>
    </div>

    <div class="extra-keys-bar collapsed" id="extra-keys-bar">
        <div class="extra-keys-chevron" onclick="toggleExtraKeysBar()" id="ek-chevron">&#9650;</div>
        <div class="extra-keys-rows">
            <button onpointerdown="sendKey('Escape')">ESC</button>
            <button onpointerdown="sendKey('Tab')">TAB</button>
            <button onpointerdown="toggleModifier('ctrl')" id="ek-ctrl">CTRL</button>
            <button onpointerdown="toggleModifier('alt')" id="ek-alt">ALT</button>
            <button onpointerdown="sendKey('ArrowUp')">&uarr;</button>
            <button onpointerdown="sendKey('ArrowDown')">&darr;</button>
            <button onpointerdown="sendKey('ArrowLeft')">&larr;</button>
            <button onpointerdown="sendKey('ArrowRight')">&rarr;</button>
            <button onpointerdown="sendKey('Home')">HOME</button>
            <button onpointerdown="sendKey('End')">END</button>
            <button onpointerdown="sendKey('PageUp')">PGUP</button>
            <button onpointerdown="sendKey('PageDown')">PGDN</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/lib/addon-fit.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <script>
        // --- State ---
        let sessions = [];
        let panels = [];
        let layoutRoot = null;   // binary tree: { type:'leaf', panelId } | { type:'split', direction, children:[a,b], ratio }
        let _pendingSessionId = null;
        let _pendingSessionName = null;
        let allowedCommands = [];
        let selectedCwd = null;
        let focusedPanelId = null;
        const hasXterm = typeof Terminal !== 'undefined';

        // --- Multi-Server Registry ---
        let servers = [];
        let serverConnected = {};   // serverKey -> boolean
        let _serverConfigs = {};    // serverKey -> { allowed_commands, default_directories }
        let _newSessionServer = 'local';

        function loadServers() {
            try {
                const stored = localStorage.getItem('conductor-servers');
                if (stored) {
                    servers = JSON.parse(stored);
                    // Ensure local server always exists
                    if (!servers.find(s => s.key === 'local')) {
                        servers.unshift({ key: 'local', label: 'This Machine', url: null, enabled: true });
                    }
                }
            } catch (e) {}
            if (!servers.length) {
                servers = [{ key: 'local', label: 'This Machine', url: null, enabled: true }];
            }
        }

        function saveServers() {
            localStorage.setItem('conductor-servers', JSON.stringify(servers));
        }

        function addServer(url, label) {
            url = url.replace(/\/+$/, '');
            // Ensure protocol
            if (!/^https?:\/\//.test(url)) url = 'http://' + url;
            const key = url.replace(/^https?:\/\//, '');
            if (servers.find(s => s.key === key)) return null;
            const server = { key, label: label || key, url, enabled: true };
            servers.push(server);
            saveServers();
            return server;
        }

        function removeServer(key) {
            if (key === 'local') return;
            servers = servers.filter(s => s.key !== key);
            saveServers();
            delete serverConnected[key];
            delete _serverConfigs[key];
            // Close panels for this server
            const toClose = panels.filter(p => p.server === key).map(p => p.id);
            toClose.forEach(id => closePanel(id));
            // Remove sessions for this server
            sessions = sessions.filter(s => s._server !== key);
            renderSessionList();
            updateServerSelectorVisibility();
        }

        function serverUrl(serverKey, path) {
            if (serverKey === 'local') return path;
            const server = servers.find(s => s.key === serverKey);
            return server ? server.url + path : path;
        }

        function serverWsUrl(serverKey, path) {
            if (serverKey === 'local') {
                return `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}${path}`;
            }
            const server = servers.find(s => s.key === serverKey);
            if (!server) return path;
            return server.url.replace(/^http/, 'ws') + path;
        }

        function compoundId(serverKey, sessionId) {
            if (!_isMultiServer()) return sessionId;
            return serverKey + '::' + sessionId;
        }

        function parseCompoundId(id) {
            const sep = id.indexOf('::');
            if (sep < 0) return { server: 'local', sessionId: id };
            return { server: id.substring(0, sep), sessionId: id.substring(sep + 2) };
        }

        function _isMultiServer() {
            return servers.filter(s => s.enabled).length > 1;
        }

        function getServerLabel(serverKey) {
            const server = servers.find(s => s.key === serverKey);
            return server ? server.label : serverKey;
        }

        // HTML-escape untrusted strings before interpolating into innerHTML
        function escHtml(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }

        function setServerConnectedStatus(serverKey, connected) {
            serverConnected[serverKey] = connected;
            // Main status bar tracks local server
            const el = document.getElementById('server-status');
            if (serverConnected['local'] === false) {
                el.classList.add('disconnected');
            } else {
                el.classList.remove('disconnected');
            }
        }

        // Terminal color scheme presets
        const THEMES = {
            default: {
                label: 'Default', dot: '#12122a',
                background: '#12122a', foreground: '#d0d0e0',
                cursor: '#8080ff', selectionBackground: '#3a3a7a',
                black: '#000000', red: '#ff5555', green: '#50fa7b', yellow: '#f1fa8c',
                blue: '#6272a4', magenta: '#ff79c6', cyan: '#8be9fd', white: '#f8f8f2',
            },
            dark: {
                label: 'Dark', dot: '#000000',
                background: '#000000', foreground: '#c0c0c0',
                cursor: '#ffffff', selectionBackground: '#333333',
                black: '#000000', red: '#cc0000', green: '#4e9a06', yellow: '#c4a000',
                blue: '#3465a4', magenta: '#75507b', cyan: '#06989a', white: '#d3d7cf',
            },
            mid: {
                label: 'Mid', dot: '#1e1e2e',
                background: '#1e1e2e', foreground: '#cdd6f4',
                cursor: '#f5e0dc', selectionBackground: '#45475a',
                black: '#45475a', red: '#f38ba8', green: '#a6e3a1', yellow: '#f9e2af',
                blue: '#89b4fa', magenta: '#f5c2e7', cyan: '#94e2d5', white: '#bac2de',
            },
            bright: {
                label: 'Bright', dot: '#fafafa',
                background: '#fafafa', foreground: '#383a42',
                cursor: '#526eff', selectionBackground: '#bfceff',
                black: '#383a42', red: '#e45649', green: '#50a14f', yellow: '#c18401',
                blue: '#4078f2', magenta: '#a626a4', cyan: '#0184bc', white: '#fafafa',
            },
            bernstein: {
                label: 'Bernstein', dot: '#ffb000',
                background: '#1a0e00', foreground: '#ffb000',
                cursor: '#ffb000', selectionBackground: '#4a2800',
                black: '#1a0e00', red: '#ffb000', green: '#ffb000', yellow: '#ffb000',
                blue: '#ffb000', magenta: '#ffb000', cyan: '#ffb000', white: '#ffb000',
                brightBlack: '#805800', brightRed: '#ffb000', brightGreen: '#ffb000', brightYellow: '#ffb000',
                brightBlue: '#ffb000', brightMagenta: '#ffb000', brightCyan: '#ffb000', brightWhite: '#ffb000',
            },
            green: {
                label: 'Green', dot: '#33ff00',
                background: '#001a00', foreground: '#33ff00',
                cursor: '#33ff00', selectionBackground: '#0a4400',
                black: '#001a00', red: '#33ff00', green: '#33ff00', yellow: '#33ff00',
                blue: '#33ff00', magenta: '#33ff00', cyan: '#33ff00', white: '#33ff00',
                brightBlack: '#1a8000', brightRed: '#33ff00', brightGreen: '#33ff00', brightYellow: '#33ff00',
                brightBlue: '#33ff00', brightMagenta: '#33ff00', brightCyan: '#33ff00', brightWhite: '#33ff00',
            },
        };
        const THEME_ORDER = ['default', 'dark', 'mid', 'bright', 'bernstein', 'green'];

        // Return a contrasting grey for the ring around a dot
        function contrastGrey(hex) {
            const c = hex.replace('#', '');
            const r = parseInt(c.substring(0, 2), 16);
            const g = parseInt(c.substring(2, 4), 16);
            const b = parseInt(c.substring(4, 6), 16);
            const lum = (r * 299 + g * 587 + b * 114) / 1000;
            return lum > 128 ? '#404040' : '#c0c0c0';
        }

        // Debounce helper
        function debounce(fn, ms) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => fn(...args), ms);
            };
        }

        // Debounced fit + resize per panel.
        // Batches rapid ResizeObserver / window resize events into one fit() call.
        const _panelFitters = {};
        function fitPanel(panel) {
            if (!_panelFitters[panel.id]) {
                _panelFitters[panel.id] = debounce((p) => {
                    if (!p.fitAddon || !p._termOpened) return;
                    try {
                        p.fitAddon.fit();
                    } catch (e) { return; }

                    // Enforce minimum columns — narrow panels get horizontal scroll instead of reflow
                    if (p.terminal.cols < MIN_COLS) {
                        p.terminal.resize(MIN_COLS, p.terminal.rows);
                    }

                    // Send actual applied dimensions to PTY
                    syncResizeToPTY(p);
                }, 100);
            }
            _panelFitters[panel.id](panel);
        }

        // --- Config ---
        async function fetchConfig(serverKey) {
            serverKey = serverKey || 'local';
            try {
                const resp = await fetch(serverUrl(serverKey, '/config'));
                const cfg = await resp.json();
                _serverConfigs[serverKey] = cfg;
                if (serverKey === _newSessionServer) {
                    allowedCommands = cfg.allowed_commands || [];
                    populateCommandSelect();
                    browseTo('~', serverKey);
                }
            } catch (e) {}
        }

        function populateCommandSelect() {
            const sel = document.getElementById('new-command');
            sel.innerHTML = allowedCommands.map(c =>
                `<option value="${c.command}">${c.label}</option>`
            ).join('');
        }

        // --- Directory Browser ---
        async function browseTo(path, serverKey) {
            serverKey = serverKey || _newSessionServer;
            try {
                const resp = await fetch(serverUrl(serverKey, `/browse?path=${encodeURIComponent(path)}`));
                const data = await resp.json();
                selectedCwd = data.current;
                renderDirPicker(data, serverKey);
                validateNewSession();
            } catch (e) {}
        }

        function renderDirPicker(data, serverKey) {
            const picker = document.getElementById('dir-picker');
            const shortPath = data.current.replace(/^\/home\/[^/]+/, '~').replace(/^C:\\Users\\[^\\]+/, '~');
            let html = `
                <div class="dir-current">
                    ${data.parent ? `<button onclick="browseTo('${data.parent.replace(/'/g, "\\'")}', '${serverKey}')" title="Go up">&#8592;</button>` : ''}
                    <span>${shortPath}</span>
                </div>
            `;
            if (data.directories.length === 0) {
                html += '<div class="dir-empty">No subdirectories</div>';
            } else {
                html += data.directories.map(d =>
                    `<div class="dir-entry" onclick="browseTo('${d.path.replace(/'/g, "\\'")}', '${serverKey}')">
                        <span class="dir-icon">&#128193;</span>
                        <span>${d.name}</span>
                    </div>`
                ).join('');
            }
            picker.innerHTML = html;
        }

        // --- Session List ---
        async function fetchAllSessions() {
            const enabledServers = servers.filter(s => s.enabled);
            const results = await Promise.allSettled(
                enabledServers.map(async (srv) => {
                    const url = serverUrl(srv.key, '/sessions');
                    const resp = await fetch(url);
                    const data = await resp.json();
                    return { serverKey: srv.key, sessions: data };
                })
            );

            const allSessions = [];
            for (let i = 0; i < results.length; i++) {
                const srv = enabledServers[i];
                if (results[i].status === 'fulfilled') {
                    setServerConnectedStatus(srv.key, true);
                    const serverSessions = results[i].value.sessions;
                    serverSessions.forEach(s => {
                        s._server = srv.key;
                        s._compoundId = compoundId(srv.key, s.id);
                    });
                    allSessions.push(...serverSessions);
                } else {
                    setServerConnectedStatus(srv.key, false);
                    // Don't keep stale sessions — clear them so the UI stays honest.
                    // Also close any open panels for this server.
                    const stalePanels = panels.filter(p => p.server === srv.key).map(p => p.id);
                    stalePanels.forEach(id => closePanel(id));
                }
            }

            sessions = allSessions;
            renderSessionList();
            validateNewSession();
        }

        function getCommandLabel(command) {
            const match = allowedCommands.find(c => c.command === command);
            return match ? match.label : command.split(/\s/)[0];
        }

        function renderSessionList() {
            const list = document.getElementById('session-list');
            if (sessions.length === 0) {
                list.innerHTML = '<div style="padding:12px;color:#404060;font-size:13px;">No sessions</div>';
                return;
            }

            const multi = _isMultiServer();

            if (!multi) {
                // Single server mode — render flat list (identical to original)
                list.innerHTML = sessions.map(s => renderSessionItem(s)).join('');
                return;
            }

            // Multi-server mode — group by server
            const groups = {};
            const serverOrder = servers.filter(s => s.enabled).map(s => s.key);
            serverOrder.forEach(k => { groups[k] = []; });
            sessions.forEach(s => {
                if (!groups[s._server]) groups[s._server] = [];
                groups[s._server].push(s);
            });

            let html = '';
            for (const key of serverOrder) {
                const label = getServerLabel(key);
                const connected = serverConnected[key] !== false;
                const dotClass = connected ? 'connected' : 'disconnected';
                html += `<div class="server-group-header">
                    <span class="server-dot ${dotClass}"></span>
                    <span>${escHtml(label)}</span>
                </div>`;
                if (groups[key] && groups[key].length > 0) {
                    html += groups[key].map(s => renderSessionItem(s)).join('');
                } else {
                    html += '<div style="padding:4px 12px;color:#404060;font-size:11px;">No sessions</div>';
                }
            }
            list.innerHTML = html;
        }

        function renderSessionItem(s) {
            const cid = s._compoundId || s.id;
            const isOpen = panels.some(p => p.id === cid);
            const isFocused = focusedPanelId === cid;
            const appLabel = getCommandLabel(s.command);
            const isResumable = s.status === 'exited' && s.resume_id;
            // Escape single quotes in compound ID for onclick
            const cidEsc = cid.replace(/'/g, "\\'");
            const nameEsc = s.name.replace(/'/g, "\\'");

            let actions;
            if (isResumable) {
                actions = `
                    <button onclick="event.stopPropagation();resumeSession('${cidEsc}')" title="Resume session" style="color:#44dd77;">&#9654;</button>
                    <button onclick="event.stopPropagation();dismissSession('${cidEsc}')" title="Dismiss">&times;</button>
                `;
            } else {
                actions = `<button onclick="event.stopPropagation();killSession('${cidEsc}')" title="Stop">&times;</button>`;
            }

            const statusBadge = isResumable
                ? '<span class="session-status exited" style="font-size:9px;margin-left:4px;">resumable</span>'
                : '';

            return `
                <div class="session-item ${isFocused ? 'focused' : isOpen ? 'open' : ''}" ${isResumable ? '' : `onclick="focusSession('${cidEsc}', '${nameEsc}', event)"`}>
                    <div class="session-name">
                        <div>${escHtml(s.name)}${statusBadge}</div>
                        <div style="font-size:10px;color:#606080;font-weight:400;">${escHtml(appLabel)}</div>
                    </div>
                    <div class="session-actions">
                        ${actions}
                    </div>
                </div>
            `;
        }

        // --- Panels ---
        function setFocus(id) {
            if (focusedPanelId === id) return;
            focusedPanelId = id;
            // Update panel visual focus
            panels.forEach(p => {
                if (p.element) p.element.classList.toggle('panel-focused', p.id === id);
            });
            renderSessionList();
        }

        function focusSession(id, name, evt) {
            closeDrawer();
            const existing = panels.find(p => p.id === id);
            if (existing) {
                hidePlacementMenu();
                setFocus(id);
                if (existing.terminal) existing.terminal.focus();
                return;
            }
            // If no panels open, open directly
            if (panels.length === 0) {
                openSession(id, name, 'right');
                return;
            }
            // Show placement menu at the click position
            showPlacementMenu(id, name, evt);
        }

        function showPlacementMenu(id, name, evt) {
            _pendingSessionId = id;
            _pendingSessionName = name;
            const menu = document.getElementById('placement-menu');
            // Position at click location
            if (evt) {
                const menuW = 120, menuH = 160;
                let x = evt.clientX - menuW / 2;
                let y = evt.clientY - menuH / 2;
                // Keep within viewport
                x = Math.max(4, Math.min(x, window.innerWidth - menuW - 4));
                y = Math.max(4, Math.min(y, window.innerHeight - menuH - 4));
                menu.style.left = x + 'px';
                menu.style.top = y + 'px';
            } else {
                menu.style.left = '220px';
                menu.style.top = '100px';
            }
            menu.classList.add('open');
        }

        function hidePlacementMenu() {
            document.getElementById('placement-menu').classList.remove('open');
            _pendingSessionId = null;
            _pendingSessionName = null;
        }

        function placeSession(direction) {
            if (!_pendingSessionId) return;
            const id = _pendingSessionId;
            const name = _pendingSessionName;
            hidePlacementMenu();
            if (direction === 'single') {
                // Close all other panels, open this one full-screen
                const toClose = panels.map(p => p.id);
                toClose.forEach(pid => closePanel(pid));
                openSession(id, name, 'right');
            } else {
                openSession(id, name, direction);
            }
        }

        // Close placement menu on click-outside or Escape
        document.addEventListener('mousedown', (e) => {
            const menu = document.getElementById('placement-menu');
            if (menu.classList.contains('open') && !menu.contains(e.target)) {
                hidePlacementMenu();
            }
        });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') hidePlacementMenu();
        });

        // Placement menu status line on hover
        document.getElementById('placement-menu').addEventListener('mouseover', (e) => {
            const btn = e.target.closest('button[data-hint]');
            document.getElementById('pm-status').textContent = btn ? btn.dataset.hint : '';
        });
        document.getElementById('placement-menu').addEventListener('mouseleave', () => {
            document.getElementById('pm-status').textContent = '';
        });

        function openSession(id, name, direction) {
            if (panels.find(p => p.id === id)) return;

            const { server, sessionId } = parseCompoundId(id);
            const panel = {
                id, server, sessionId, name,
                ws: null, terminal: null, fitAddon: null,
                element: null, _resizeObserver: null, _theme: 'default'
            };
            panels.push(panel);
            buildPanelElement(panel);
            insertIntoTree(id, direction || 'right');
            layoutPanels();
            setFocus(id);
        }

        // --- Layout Tree ---
        function findLeaf(node, panelId) {
            if (!node) return null;
            if (node.type === 'leaf') return node.panelId === panelId ? node : null;
            return findLeaf(node.children[0], panelId) || findLeaf(node.children[1], panelId);
        }

        function replaceInTree(node, target, replacement) {
            // If root itself is the target
            if (node === target) {
                Object.keys(node).forEach(k => delete node[k]);
                Object.assign(node, replacement);
                return true;
            }
            if (node.type !== 'split') return false;
            for (let i = 0; i < 2; i++) {
                if (node.children[i] === target) {
                    node.children[i] = replacement;
                    return true;
                }
                if (replaceInTree(node.children[i], target, replacement)) return true;
            }
            return false;
        }

        function insertIntoTree(panelId, direction) {
            const newLeaf = { type: 'leaf', panelId };
            if (!layoutRoot) {
                layoutRoot = newLeaf;
                return;
            }
            if (panels.length <= 1) {
                // Only one panel — just set as root
                layoutRoot = newLeaf;
                return;
            }
            const focusedLeaf = findLeaf(layoutRoot, focusedPanelId);
            if (!focusedLeaf) {
                // Fallback: wrap root
                const splitDir = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';
                const first = (direction === 'right' || direction === 'bottom') ? layoutRoot : newLeaf;
                const second = (direction === 'right' || direction === 'bottom') ? newLeaf : layoutRoot;
                layoutRoot = { type: 'split', direction: splitDir, children: [first, second], ratio: 0.5 };
                return;
            }
            const splitDir = (direction === 'left' || direction === 'right') ? 'horizontal' : 'vertical';
            const existingLeaf = { type: 'leaf', panelId: focusedPanelId };
            const first = (direction === 'right' || direction === 'bottom') ? existingLeaf : newLeaf;
            const second = (direction === 'right' || direction === 'bottom') ? newLeaf : existingLeaf;
            const newSplit = { type: 'split', direction: splitDir, children: [first, second], ratio: 0.5 };
            replaceInTree(layoutRoot, focusedLeaf, newSplit);
        }

        function removeFromTree(panelId) {
            if (!layoutRoot) return;
            if (layoutRoot.type === 'leaf') {
                if (layoutRoot.panelId === panelId) layoutRoot = null;
                return;
            }
            _removeLeaf(layoutRoot, null, -1, panelId);
        }

        function _removeLeaf(node, parent, childIdx, panelId) {
            if (node.type === 'leaf') {
                if (node.panelId === panelId && parent) {
                    const sibling = parent.children[1 - childIdx];
                    replaceInTree(layoutRoot, parent, sibling);
                    return true;
                }
                return false;
            }
            if (_removeLeaf(node.children[0], node, 0, panelId)) return true;
            return _removeLeaf(node.children[1], node, 1, panelId);
        }

        function firstLeafId(node) {
            if (!node) return null;
            if (node.type === 'leaf') return node.panelId;
            return firstLeafId(node.children[0]);
        }

        const MIN_COLS = 80;

        // Build the panel DOM + terminal ONCE. This is only called when a session is first opened.
        function buildPanelElement(panel) {
            const div = document.createElement('div');
            div.className = 'panel';

            const termEl = document.createElement('div');
            termEl.className = 'panel-terminal';

            // Wrapper enforces min-width so the terminal never shrinks below MIN_COLS.
            // When the panel is narrower, .panel-terminal scrolls horizontally.
            const termWrapper = document.createElement('div');
            termWrapper.className = 'terminal-wrapper';
            termEl.appendChild(termWrapper);

            // Show server name in panel header when multi-server
            const serverLabel = _isMultiServer() ? ` <span style="font-size:10px;color:#606080;">(${escHtml(getServerLabel(panel.server))})</span>` : '';

            // panel.id is serverKey::sessionName — safe chars only (validated by _SAFE_NAME + IP:port)
            // Escape for JS string context (defense in depth)
            const pid = panel.id.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
            div.innerHTML = `
                <div class="panel-header">
                    <span class="panel-title">${escHtml(panel.name)}${serverLabel}</span>
                    <div class="panel-header-actions" style="position:relative;">
                        <button class="theme-btn" id="theme-btn-${escHtml(panel.id)}" onclick="toggleThemeMenu('${pid}')" title="Color scheme"><span class="theme-ring" style="background:${THEMES['default'].dot};border-color:${contrastGrey(THEMES['default'].dot)}"></span></button>
                        <div class="theme-menu" id="theme-menu-${escHtml(panel.id)}">
                            ${THEME_ORDER.map(k => `<a onclick="event.stopPropagation();setTheme('${pid}','${k}')" data-theme="${k}" data-cursor="${THEMES[k].cursor}"><span class="theme-dot" style="background:${THEMES[k].dot};border-color:${contrastGrey(THEMES[k].dot)}"></span>${THEMES[k].label}</a>`).join('')}
                        </div>
                        <button class="font-btn" onclick="changeFontSize('${pid}', -1)" title="Smaller">&#8722;</button>
                        <button class="font-btn" onclick="changeFontSize('${pid}', 1)" title="Bigger">+</button>
                        <button class="close-btn" onclick="closePanel('${pid}')">&times;</button>
                    </div>
                </div>
            `;
            div.appendChild(termEl);

            panel.element = div;
            panel._termEl = termEl;
            panel._termWrapper = termWrapper;

            if (hasXterm) {
                const defT = THEMES['default'];
                const term = new Terminal({
                    cursorBlink: true,
                    fontSize: window.innerWidth <= 700 ? 8 : 14,
                    fontFamily: "'Consolas', 'Monaco', 'Courier New', monospace",
                    theme: {
                        background: defT.background, foreground: defT.foreground,
                        cursor: defT.cursor, selectionBackground: defT.selectionBackground,
                        black: defT.black, red: defT.red, green: defT.green, yellow: defT.yellow,
                        blue: defT.blue, magenta: defT.magenta, cyan: defT.cyan, white: defT.white,
                        brightBlack: defT.brightBlack, brightRed: defT.brightRed,
                        brightGreen: defT.brightGreen, brightYellow: defT.brightYellow,
                        brightBlue: defT.brightBlue, brightMagenta: defT.brightMagenta,
                        brightCyan: defT.brightCyan, brightWhite: defT.brightWhite,
                    },
                    scrollback: 5000,
                    convertEol: false,
                });

                panel.terminal = term;

                if (typeof FitAddon !== 'undefined') {
                    const fitAddon = new FitAddon.FitAddon();
                    term.loadAddon(fitAddon);
                    panel.fitAddon = fitAddon;
                }

                term.onData((data) => {
                    if (panel.ws && panel.ws.readyState === WebSocket.OPEN) {
                        panel.ws.send(data);
                    }
                });
            }

            // Clicking anywhere on the panel sets focus
            div.addEventListener('mousedown', () => setFocus(panel.id));
            div.addEventListener('touchstart', () => setFocus(panel.id), { passive: true });
        }

        // Ensure the xterm terminal is opened into its container and sized correctly.
        // Safe to call multiple times — only opens once.
        function ensureTerminalOpen(panel) {
            if (!panel.terminal || !panel._termEl) return;
            if (panel._termOpened) {
                // Already open — just refit
                fitPanel(panel);
                return;
            }

            // Open into the wrapper (which has min-width for horizontal scroll)
            const target = panel._termWrapper || panel._termEl;
            panel.terminal.open(target);
            panel._termOpened = true;

            if (panel.fitAddon) {
                panel.fitAddon.fit();

                // Measure actual char width and set wrapper min-width so terminal never shrinks below MIN_COLS
                if (panel.terminal.cols > 0 && target.clientWidth > 0) {
                    const charWidth = target.clientWidth / panel.terminal.cols;
                    target.style.minWidth = Math.ceil(MIN_COLS * charWidth) + 'px';
                }

                // Send resize to PTY so the app redraws at the correct size,
                // then connect WebSocket — buffer replay will arrive after redraw.
                syncResizeToPTY(panel);
                setTimeout(() => {
                    if (!panel.ws) connectWebSocket(panel);
                }, 150);

                // Watch the scroll container (not the wrapper) for size changes
                if (typeof ResizeObserver !== 'undefined') {
                    panel._resizeObserver = new ResizeObserver(() => fitPanel(panel));
                    panel._resizeObserver.observe(panel._termEl);
                }
            }
        }

        // Rearrange existing panel elements into the layout using the binary tree.
        function layoutPanels() {
            const container = document.getElementById('panels');

            // Detach all children without destroying them
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            if (!layoutRoot || panels.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">&#9837;</div>
                        <div>Select a session or create a new one</div>
                    </div>`;
                renderSessionList();
                return;
            }

            const dom = renderNode(layoutRoot);
            container.appendChild(dom);

            renderSessionList();

            // Open terminals that haven't been opened yet + refit all
            requestAnimationFrame(() => {
                panels.forEach(p => ensureTerminalOpen(p));
            });
        }

        function renderNode(node) {
            if (node.type === 'leaf') {
                const panel = panels.find(p => p.id === node.panelId);
                const pane = document.createElement('div');
                pane.className = 'split-pane';
                pane.style.flex = '1';
                if (panel && panel.element) pane.appendChild(panel.element);
                return pane;
            }

            // Split node
            const wrapper = document.createElement('div');
            wrapper.className = `split-container ${node.direction}`;

            const child1 = renderNode(node.children[0]);
            const pane1 = wrapInSplitPane(child1);
            pane1.style.flex = String(node.ratio);
            wrapper.appendChild(pane1);

            const handle = document.createElement('div');
            handle.className = `split-handle ${node.direction === 'horizontal' ? 'h-handle' : 'v-handle'}`;
            initDragHandle(handle, wrapper, node.direction, node);
            wrapper.appendChild(handle);

            const child2 = renderNode(node.children[1]);
            const pane2 = wrapInSplitPane(child2);
            pane2.style.flex = String(1 - node.ratio);
            wrapper.appendChild(pane2);

            return wrapper;
        }

        // Ensure a rendered child is always wrapped in a split-pane for consistent flex layout.
        // Leaf nodes already return a split-pane; split nodes return a split-container that needs wrapping.
        function wrapInSplitPane(el) {
            if (el.classList.contains('split-pane')) return el;
            const pane = document.createElement('div');
            pane.className = 'split-pane';
            pane.appendChild(el);
            return pane;
        }

        function changeFontSize(id, delta) {
            const panel = panels.find(p => p.id === id);
            if (!panel || !panel.terminal) return;
            const current = panel.terminal.options.fontSize || 14;
            const next = Math.min(28, Math.max(3, current + delta));
            panel.terminal.options.fontSize = next;
            // Recalculate wrapper min-width for new char size
            const target = panel._termWrapper || panel._termEl;
            if (panel.fitAddon) {
                panel.fitAddon.fit();
                if (panel.terminal.cols > 0 && target.clientWidth > 0) {
                    const charWidth = target.clientWidth / panel.terminal.cols;
                    target.style.minWidth = Math.ceil(MIN_COLS * charWidth) + 'px';
                }
                if (panel.terminal.cols < MIN_COLS) {
                    panel.terminal.resize(MIN_COLS, panel.terminal.rows);
                }
                syncResizeToPTY(panel);
            }
        }

        // --- Extra keys toolbar ---
        // Map of key names to the escape sequences they produce.
        const _KEY_SEQS = {
            Escape: '\x1b',
            Tab: '\t',
            ArrowUp: '\x1b[A',
            ArrowDown: '\x1b[B',
            ArrowRight: '\x1b[C',
            ArrowLeft: '\x1b[D',
            Home: '\x1b[H',
            End: '\x1b[F',
            PageUp: '\x1b[5~',
            PageDown: '\x1b[6~',
        };

        // Global modifier state for the extra-keys bar.
        const _ekMods = { ctrl: false, alt: false };

        function _getFocusedPanel() {
            return panels.find(p => p.id === focusedPanelId);
        }

        function toggleExtraKeysBar() {
            const bar = document.getElementById('extra-keys-bar');
            if (!bar) return;
            bar.classList.toggle('collapsed');
            const chevron = document.getElementById('ek-chevron');
            if (chevron) chevron.innerHTML = bar.classList.contains('collapsed') ? '&#9650;' : '&#9660;';
        }

        function toggleModifier(mod) {
            _ekMods[mod] = !_ekMods[mod];
            const btn = document.getElementById('ek-' + mod);
            if (btn) btn.classList.toggle('modifier-active', _ekMods[mod]);
        }

        function _clearModifiers() {
            _ekMods.ctrl = false;
            _ekMods.alt = false;
            const ctrlBtn = document.getElementById('ek-ctrl');
            const altBtn = document.getElementById('ek-alt');
            if (ctrlBtn) ctrlBtn.classList.remove('modifier-active');
            if (altBtn) altBtn.classList.remove('modifier-active');
        }

        function sendKey(key) {
            const panel = _getFocusedPanel();
            if (!panel || !panel.ws || panel.ws.readyState !== WebSocket.OPEN) return;

            let seq = _KEY_SEQS[key] || '';

            // Ctrl + arrow produces CSI 1;5 <dir> sequences
            if (_ekMods.ctrl) {
                const ctrlArrows = {
                    ArrowUp: '\x1b[1;5A', ArrowDown: '\x1b[1;5B',
                    ArrowRight: '\x1b[1;5C', ArrowLeft: '\x1b[1;5D',
                };
                if (ctrlArrows[key]) seq = ctrlArrows[key];
            }

            // Alt + key: prepend ESC
            if (_ekMods.alt && _KEY_SEQS[key]) {
                seq = '\x1b' + _KEY_SEQS[key];
            }

            if (seq) {
                panel.ws.send(seq);
                _clearModifiers();
            }
        }

        // Reposition the extra-keys bar above the virtual keyboard.
        // The meta viewport `interactive-widget=resizes-content` handles
        // most modern browsers.  This is the fallback for older ones:
        // when the keyboard opens, visualViewport shrinks and we use that
        // to compute the offset.
        let _ekKeyboardOpen = false;
        function _updateExtraKeysPosition() {
            const bar = document.getElementById('extra-keys-bar');
            if (!bar || !window.visualViewport) return;
            const vv = window.visualViewport;
            const kbHeight = Math.round(window.innerHeight - vv.height - vv.offsetTop);
            if (kbHeight > 50) {
                // Keyboard is open — offset the bar and auto-expand
                bar.style.bottom = kbHeight + 'px';
                if (!_ekKeyboardOpen) {
                    _ekKeyboardOpen = true;
                    if (bar.classList.contains('collapsed')) {
                        bar.classList.remove('collapsed');
                        const chevron = document.getElementById('ek-chevron');
                        if (chevron) chevron.innerHTML = '&#9660;';
                    }
                }
            } else {
                // Keyboard closed — back to bottom
                bar.style.bottom = '0';
                _ekKeyboardOpen = false;
            }
        }
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', _updateExtraKeysPosition);
            window.visualViewport.addEventListener('scroll', _updateExtraKeysPosition);
        }

        function toggleThemeMenu(id) {
            const menu = document.getElementById(`theme-menu-${id}`);
            // Close all other theme menus first
            document.querySelectorAll('.theme-menu.open').forEach(m => {
                if (m !== menu) m.classList.remove('open');
            });
            menu.classList.toggle('open');
            // Mark active theme
            const panel = panels.find(p => p.id === id);
            const current = panel?._theme || 'default';
            menu.querySelectorAll('a').forEach(a => {
                const isActive = a.dataset.theme === current;
                a.classList.toggle('active', isActive);
                const dot = a.querySelector('.theme-dot');
                if (dot) dot.style.outlineColor = isActive ? '#a0a0a0' : 'transparent';
            });
        }

        function setTheme(id, themeKey) {
            const panel = panels.find(p => p.id === id);
            if (!panel || !panel.terminal) return;
            const t = THEMES[themeKey];
            if (!t) return;
            panel._theme = themeKey;
            const themeObj = {
                background: t.background, foreground: t.foreground,
                cursor: t.cursor, selectionBackground: t.selectionBackground,
                black: t.black, red: t.red, green: t.green, yellow: t.yellow,
                blue: t.blue, magenta: t.magenta, cyan: t.cyan, white: t.white,
            };
            if (t.brightBlack) {
                themeObj.brightBlack = t.brightBlack; themeObj.brightRed = t.brightRed;
                themeObj.brightGreen = t.brightGreen; themeObj.brightYellow = t.brightYellow;
                themeObj.brightBlue = t.brightBlue; themeObj.brightMagenta = t.brightMagenta;
                themeObj.brightCyan = t.brightCyan; themeObj.brightWhite = t.brightWhite;
            }
            panel.terminal.options.theme = themeObj;
            // Also update the panel background to match
            panel.element.style.background = t.background;
            // Update the theme button ring to reflect active theme
            const btn = document.getElementById(`theme-btn-${id}`);
            if (btn) {
                const ring = btn.querySelector('.theme-ring');
                if (ring) {
                    ring.style.background = t.dot;
                    ring.style.borderColor = contrastGrey(t.dot);
                }
            }
            // Update active markers in the menu
            const menu = document.getElementById(`theme-menu-${id}`);
            if (menu) {
                menu.querySelectorAll('a').forEach(a => {
                    const isActive = a.dataset.theme === themeKey;
                    a.classList.toggle('active', isActive);
                    const dot = a.querySelector('.theme-dot');
                    if (dot) dot.style.outlineColor = isActive ? '#a0a0a0' : 'transparent';
                });
                menu.classList.remove('open');
            }
        }

        // Close theme menus when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.theme-menu') && !e.target.closest('.theme-btn')) {
                document.querySelectorAll('.theme-menu.open').forEach(m => m.classList.remove('open'));
            }
        });

        function closePanel(id) {
            const idx = panels.findIndex(p => p.id === id);
            if (idx < 0) return;
            const panel = panels[idx];
            if (panel._resizeObserver) { panel._resizeObserver.disconnect(); panel._resizeObserver = null; }
            if (panel.ws) { panel.ws.close(); panel.ws = null; }
            if (panel.terminal) { panel.terminal.dispose(); }
            delete _panelFitters[panel.id];
            panels.splice(idx, 1);
            removeFromTree(id);
            // Move focus to next remaining panel
            if (focusedPanelId === id) {
                focusedPanelId = firstLeafId(layoutRoot);
            }
            layoutPanels();
            if (panels.length === 0) openDrawer();
        }

        // --- Drag handle for resizable splits ---
        function initDragHandle(handle, container, direction, treeNode) {
            let startPos, containerSize;

            function onStart(clientX, clientY) {
                handle.classList.add('dragging');
                startPos = direction === 'horizontal' ? clientX : clientY;
                containerSize = direction === 'horizontal' ? container.offsetWidth : container.offsetHeight;
                document.body.style.cursor = direction === 'horizontal' ? 'col-resize' : 'row-resize';
                document.body.style.userSelect = 'none';
            }

            function onMove(clientX, clientY) {
                if (!containerSize) return;
                const currentPos = direction === 'horizontal' ? clientX : clientY;
                const delta = currentPos - startPos;
                const handleSize = direction === 'horizontal' ? 5 : 5;
                const usable = containerSize - handleSize;
                let newRatio = (treeNode.ratio * usable + delta) / usable;
                newRatio = Math.max(0.1, Math.min(0.9, newRatio));
                treeNode.ratio = newRatio;
                // Update flex values on sibling panes
                const panes = container.querySelectorAll(':scope > .split-pane');
                if (panes.length === 2) {
                    panes[0].style.flex = String(newRatio);
                    panes[1].style.flex = String(1 - newRatio);
                }
                startPos = currentPos;
            }

            function onEnd() {
                handle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            }

            // Mouse
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                onStart(e.clientX, e.clientY);
                function mm(e) { onMove(e.clientX, e.clientY); }
                function mu() {
                    onEnd();
                    document.removeEventListener('mousemove', mm);
                    document.removeEventListener('mouseup', mu);
                }
                document.addEventListener('mousemove', mm);
                document.addEventListener('mouseup', mu);
            });

            // Touch
            handle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const t = e.touches[0];
                onStart(t.clientX, t.clientY);
                function tm(e) { const t = e.touches[0]; onMove(t.clientX, t.clientY); }
                function te() {
                    onEnd();
                    document.removeEventListener('touchmove', tm);
                    document.removeEventListener('touchend', te);
                }
                document.addEventListener('touchmove', tm, { passive: false });
                document.addEventListener('touchend', te);
            }, { passive: false });
        }

        // Send current terminal size to PTY via REST
        function syncResizeToPTY(panel) {
            if (!panel.terminal) return;
            const cols = panel.terminal.cols;
            const rows = panel.terminal.rows;
            if (cols > 0 && rows > 0) {
                fetch(serverUrl(panel.server, `/sessions/${panel.sessionId}/resize`), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ rows, cols }),
                });
            }
        }

        // --- WebSocket ---
        function connectWebSocket(panel) {
            const isReconnect = !!panel.ws;
            const wsUrl = serverWsUrl(panel.server, `/sessions/${panel.sessionId}/stream`);
            const ws = new WebSocket(wsUrl);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                setServerConnectedStatus(panel.server, true);
                // On reconnect, clear terminal to prevent duplicate content from buffer replay
                if (isReconnect && panel.terminal) {
                    panel.terminal.reset();
                }
                panel._bufferReplay = true;
                setTimeout(() => {
                    syncResizeToPTY(panel);
                    panel._bufferReplay = false;
                }, 1500);
            };

            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer && event.data.byteLength === 0) return;
                if (!panel._bufferReplay) trackActivity(panel);
                if (panel.terminal) {
                    const data = event.data instanceof ArrayBuffer
                        ? new Uint8Array(event.data) : event.data;
                    panel.terminal.write(data);
                } else {
                    const termDiv = document.getElementById(`term-${panel.id}`);
                    const pre = termDiv && termDiv.querySelector('pre');
                    if (pre) {
                        const text = event.data instanceof ArrayBuffer
                            ? new TextDecoder().decode(event.data) : event.data;
                        pre.textContent += text;
                        pre.scrollTop = pre.scrollHeight;
                    }
                }
            };

            ws.onclose = () => {
                setTimeout(() => {
                    if (panels.find(p => p.id === panel.id)) {
                        connectWebSocket(panel);
                    }
                }, 2000);
            };

            ws.onerror = () => {
                setServerConnectedStatus(panel.server, false);
            };

            panel.ws = ws;
        }

        // --- Input (fallback only) ---
        function handlePanelInput(event, id) {
            if (event.key !== 'Enter') return;
            const input = event.target;
            const panel = panels.find(p => p.id === id);
            if (panel && panel.ws && panel.ws.readyState === WebSocket.OPEN) {
                panel.ws.send(input.value + '\n');
                input.value = '';
            }
        }

        // --- New Session ---
        function toggleDrawer() {
            const layout = document.getElementById('layout');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            const isMobile = window.innerWidth <= 700;

            if (isMobile) {
                sidebar.classList.toggle('open');
                document.getElementById('sidebar-overlay').classList.toggle('open');
            } else {
                layout.classList.toggle('sidebar-collapsed');
            }

            // Update chevron direction and position
            const collapsed = layout.classList.contains('sidebar-collapsed');
            const mobileOpen = sidebar.classList.contains('open');
            const isOpen = (!isMobile && !collapsed) || (isMobile && mobileOpen);
            toggle.innerHTML = isOpen ? '&#x2039;' : '&#x203a;';
            toggle.classList.toggle('collapsed', !isOpen);

            // Refit terminals after sidebar transition
            setTimeout(() => panels.forEach(p => fitPanel(p)), 250);
        }

        function closeDrawer() {
            if (window.innerWidth > 700) return;
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            sidebar.classList.remove('open');
            document.getElementById('sidebar-overlay').classList.remove('open');
            toggle.innerHTML = '&#x203a;';
            toggle.classList.add('collapsed');
        }

        function openDrawer() {
            const layout = document.getElementById('layout');
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('drawer-toggle');
            if (window.innerWidth <= 700) {
                sidebar.classList.add('open');
                document.getElementById('sidebar-overlay').classList.add('open');
            } else {
                layout.classList.remove('sidebar-collapsed');
            }
            toggle.innerHTML = '&#x2039;';
            toggle.classList.remove('collapsed');
        }

        function toggleMenu() {
            document.getElementById('hamburger-menu').classList.toggle('open');
        }

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('hamburger-menu');
            if (menu.classList.contains('open') && !e.target.closest('.menu-wrapper')) {
                menu.classList.remove('open');
            }
        });

        function toggleAbout() {
            document.getElementById('about-dialog').classList.toggle('open');
        }

        function isLocalhost() {
            const h = location.hostname;
            return h === 'localhost' || h === '127.0.0.1' || h === '::1' || h === '0.0.0.0';
        }

        async function toggleQR() {
            const dialog = document.getElementById('qr-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                const container = document.getElementById('qr-content');
                container.innerHTML = '<p style="font-size:12px;color:#606080;">Loading...</p>';

                // Determine the best reachable URL for other devices
                let url = window.location.href;
                if (isLocalhost()) {
                    // On localhost — ask the server for its Tailscale IP
                    try {
                        const resp = await fetch('/info');
                        const info = await resp.json();
                        if (info.tailscale_ip) {
                            url = `http://${info.tailscale_ip}:${info.port}`;
                        } else {
                            container.innerHTML = `
                                <div style="padding:16px 8px;">
                                    <div style="font-size:28px;margin-bottom:10px;">&#9888;</div>
                                    <p style="font-size:13px;color:#ff9944;margin:0 0 8px;">No reachable address found</p>
                                    <p style="font-size:12px;color:#808090;margin:0;line-height:1.5;">
                                        Install Tailscale to make this server reachable from other devices.
                                    </p>
                                </div>`;
                            return;
                        }
                    } catch (e) {
                        container.innerHTML = '<p style="color:#ff6666;font-size:12px;">Could not fetch server info</p>';
                        return;
                    }
                }

                container.innerHTML = `
                    <p style="font-size:12px;color:#808090;margin-bottom:14px;">Scan to open on another device</p>
                    <canvas id="qr-canvas" style="margin:0 auto 12px;display:block;border-radius:6px;"></canvas>
                    <p style="font-size:11px;color:#606080;word-break:break-all;margin:0;"></p>`;
                container.querySelector('p:last-child').textContent = url;
                try {
                    const qr = qrcode(0, 'M');
                    qr.addData(url);
                    qr.make();
                    const count = qr.getModuleCount();
                    const scale = 6;
                    const margin = 4;
                    const size = count * scale + margin * 2 * scale;
                    const canvas = document.getElementById('qr-canvas');
                    canvas.width = size;
                    canvas.height = size;
                    canvas.style.width = '200px';
                    canvas.style.height = '200px';
                    canvas.style.imageRendering = 'pixelated';
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, size, size);
                    ctx.fillStyle = '#000000';
                    for (let r = 0; r < count; r++) {
                        for (let c = 0; c < count; c++) {
                            if (qr.isDark(r, c)) {
                                ctx.fillRect((c + margin) * scale, (r + margin) * scale, scale, scale);
                            }
                        }
                    }
                } catch (e) {
                    document.getElementById('qr-canvas').parentElement.innerHTML = '<p style="color:#ff6666;font-size:12px;">Failed to generate QR code</p>';
                }
            }
        }

        // --- Server Management Dialog ---
        async function toggleServersDialog() {
            const dialog = document.getElementById('servers-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                renderServersDialog();
                await fetchSelfInfo();   // sets PORT before peer URLs are built
                fetchTailscalePeers();
            } else {
                stopQRScanner();
            }
        }

        async function fetchSelfInfo() {
            const el = document.getElementById('server-self-info');
            try {
                const resp = await fetch('/info');
                const info = await resp.json();
                if (info.port) PORT = info.port;

                // Update local server label to real hostname
                if (info.hostname) {
                    const local = servers.find(s => s.key === 'local');
                    if (local) {
                        local.label = '\u2605 ' + info.hostname;
                        saveServers();
                        renderSessionList();
                    }
                }

                let html = '<div style="margin-bottom:4px;font-weight:500;color:#a0a0d0;">This server</div>';
                html += `<div>Hostname: ${escHtml(info.hostname)}</div>`;
                if (info.tailscale_name) {
                    html += `<div>MagicDNS: <span class="self-url">${escHtml(info.tailscale_name)}:${escHtml(String(info.port))}</span></div>`;
                }
                if (info.tailscale_ip) {
                    html += `<div>Tailscale: <span class="self-url">${escHtml(info.tailscale_ip)}:${escHtml(String(info.port))}</span></div>`;
                }
                if (!info.tailscale_ip && !info.tailscale_name) {
                    html += `<div>Port: ${escHtml(String(info.port))}</div>`;
                }
                el.innerHTML = html;
            } catch (e) {
                el.innerHTML = '<div style="color:#606080;">Could not fetch server info</div>';
            }
        }

        async function fetchTailscalePeers() {
            const content = document.getElementById('tailscale-picker-content');
            if (!content) return;
            try {
                const resp = await fetch('/tailscale/peers');
                const peers = await resp.json();
                if (!peers || peers.length === 0) {
                    content.innerHTML = '<div style="font-size:12px;color:#505070;padding:4px 0;">No Tailscale peers online</div>';
                    return;
                }
                // Filter out peers already added as servers
                const existingKeys = new Set(servers.map(s => s.key));
                const available = peers.filter(p => {
                    const key = p.ip + ':' + PORT;
                    const dnsKey = p.dns_name ? p.dns_name + ':' + PORT : null;
                    return !existingKeys.has(key) && (!dnsKey || !existingKeys.has(dnsKey));
                });
                if (available.length === 0) {
                    content.innerHTML = '<div style="font-size:12px;color:#505070;padding:4px 0;">All Tailscale peers already added</div>';
                    return;
                }
                content.innerHTML = `
                    <div style="display:flex;gap:6px;">
                        <select id="tailscale-select" style="flex:1;padding:7px 10px;background:#0a0a1a;border:1px solid #2a2a5a;color:#e0e0e0;border-radius:5px;font-size:13px;">
                            ${available.map(p => {
                                const label = p.dns_name || p.hostname || p.ip;
                                const url = 'http://' + p.ip + ':' + PORT;
                                return `<option value="${escHtml(url)}" data-label="${escHtml(label)}">${escHtml(p.hostname)} (${escHtml(p.ip)})</option>`;
                            }).join('')}
                        </select>
                        <button onclick="addTailscaleDevice()" style="padding:7px 14px;background:#2a2a6a;border:1px solid #3a3aaa;color:#e0e0e0;border-radius:5px;cursor:pointer;font-size:13px;white-space:nowrap;">Add</button>
                    </div>`;
            } catch (e) {
                content.innerHTML = '<div style="font-size:12px;color:#505070;padding:4px 0;">Tailscale not available</div>';
            }
        }

        // Port used when constructing URLs for Tailscale peers (updated from /info)
        let PORT = 7777;

        async function addTailscaleDevice() {
            const sel = document.getElementById('tailscale-select');
            const url = sel.value;
            if (!url) return;
            const label = sel.options[sel.selectedIndex].dataset.label || url;

            const info = await probeServer(url);
            if (info) {
                const finalLabel = info.tailscale_name || info.hostname || label;
                const server = addServer(info.url, finalLabel);
                if (server) {
                    renderServersDialog();
                    updateServerSelectorVisibility();
                    fetchConfig(server.key);
                    fetchAllSessions();
                }
            } else {
                // Server not reachable but add anyway — user can see red dot
                addServer(url, label);
                renderServersDialog();
                updateServerSelectorVisibility();
                fetchAllSessions();
            }
            // Refresh the dropdown to remove the added device
            fetchTailscalePeers();
        }

        function renderServersDialog() {
            const list = document.getElementById('servers-list');
            list.innerHTML = servers.map(s => {
                const connected = serverConnected[s.key] !== false;
                const dotClass = connected ? 'connected' : 'disconnected';
                const removeBtn = s.key !== 'local' ?
                    `<button onclick="removeServer('${s.key.replace(/'/g, "\\'")}');renderServersDialog()" title="Remove">&times;</button>` : '';
                const urlText = s.url || '(local)';
                return `<div class="server-list-item">
                    <span class="server-dot ${dotClass}"></span>
                    <div class="server-info">
                        <div class="server-label">${escHtml(s.label)}</div>
                        <div class="server-url-text">${escHtml(urlText)}</div>
                    </div>
                    ${removeBtn}
                </div>`;
            }).join('');
        }

        async function probeServer(url) {
            url = url.replace(/\/+$/, '');
            if (!/^https?:\/\//.test(url)) url = 'http://' + url;
            try {
                const resp = await fetch(url + '/info', { signal: AbortSignal.timeout(5000) });
                if (!resp.ok) return null;
                const info = await resp.json();
                return { url, hostname: info.hostname, port: info.port, tailscale_name: info.tailscale_name };
            } catch (e) {
                return null;
            }
        }

        async function addServerFromInput() {
            const input = document.getElementById('server-url-input');
            const url = input.value.trim();
            if (!url) return;

            // Probe the server first
            const info = await probeServer(url);
            if (!info) {
                input.style.borderColor = '#ff6666';
                setTimeout(() => { input.style.borderColor = '#2a2a5a'; }, 2000);
                return;
            }

            const label = info.tailscale_name || info.hostname || url.replace(/^https?:\/\//, '');
            const server = addServer(info.url, label);
            if (!server) {
                // Already exists
                input.value = '';
                return;
            }

            input.value = '';
            renderServersDialog();
            updateServerSelectorVisibility();
            // Fetch config and sessions for the new server
            fetchConfig(server.key);
            fetchAllSessions();
        }

        // --- QR Scanner ---
        let _qrScannerStream = null;
        let _qrScannerAnimFrame = null;

        function toggleQRScanner() {
            if (_qrScannerStream) {
                stopQRScanner();
            } else {
                startQRScanner();
            }
        }

        async function startQRScanner() {
            const area = document.getElementById('qr-scanner-area');
            if (typeof jsQR === 'undefined') {
                area.innerHTML = '<div style="padding:8px;font-size:12px;color:#ff6666;">QR scanner not available. Paste the URL manually.</div>';
                return;
            }

            // Camera requires HTTPS (secure context) — plain HTTP only works on localhost
            if (!window.isSecureContext) {
                area.innerHTML = `<div style="padding:10px;font-size:12px;color:#ff9944;line-height:1.5;">
                    Camera requires HTTPS.<br>
                    Use the Tailscale device picker above, or paste the URL manually.
                </div>`;
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                area.innerHTML = '<div style="padding:8px;font-size:12px;color:#ff9944;">Camera not available on this device. Paste the URL manually.</div>';
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                _qrScannerStream = stream;

                area.innerHTML = `
                    <div class="qr-scanner-container">
                        <video id="qr-video" autoplay playsinline></video>
                        <canvas id="qr-scan-canvas"></canvas>
                    </div>
                    <div class="qr-scanner-actions">
                        <button class="stop-btn" onclick="stopQRScanner()">Stop Scanner</button>
                    </div>
                    <div class="qr-scanner-status" id="qr-scan-status">Point camera at a Conductor QR code...</div>`;

                const video = document.getElementById('qr-video');
                video.srcObject = stream;
                video.play();

                video.addEventListener('loadedmetadata', () => {
                    const canvas = document.getElementById('qr-scan-canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    scanQRFrame(video, canvas, ctx);
                });
            } catch (e) {
                area.innerHTML = `<div style="padding:8px;font-size:12px;color:#ff9944;">
                    Camera access denied or unavailable.<br>Paste the server URL manually above.
                </div>`;
            }
        }

        function scanQRFrame(video, canvas, ctx) {
            if (!_qrScannerStream) return;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: 'dontInvert',
                });

                if (code && code.data) {
                    const url = code.data.trim();
                    // Validate it looks like a Conductor URL
                    if (/^https?:\/\/.+:\d+/.test(url) || /^https?:\/\/[^/]+$/.test(url)) {
                        const status = document.getElementById('qr-scan-status');
                        if (status) status.textContent = 'Found: ' + url;
                        stopQRScanner();
                        // Auto-add the server
                        handleScannedUrl(url);
                        return;
                    }
                }
            }

            _qrScannerAnimFrame = requestAnimationFrame(() => scanQRFrame(video, canvas, ctx));
        }

        async function handleScannedUrl(url) {
            const info = await probeServer(url);
            if (!info) {
                const area = document.getElementById('qr-scanner-area');
                area.innerHTML = `<div style="padding:8px;font-size:12px;color:#ff9944;">
                    Could not connect to ${escHtml(url)}. Make sure the server is running.
                </div>`;
                return;
            }

            const label = info.tailscale_name || info.hostname || url.replace(/^https?:\/\//, '');
            const server = addServer(info.url, label);
            if (server) {
                renderServersDialog();
                updateServerSelectorVisibility();
                fetchConfig(server.key);
                fetchAllSessions();
            }
            const area = document.getElementById('qr-scanner-area');
            area.innerHTML = `<div style="padding:8px;font-size:12px;color:#44dd77;">
                Added: ${escHtml(label)}
            </div>`;
        }

        function stopQRScanner() {
            if (_qrScannerAnimFrame) {
                cancelAnimationFrame(_qrScannerAnimFrame);
                _qrScannerAnimFrame = null;
            }
            if (_qrScannerStream) {
                _qrScannerStream.getTracks().forEach(t => t.stop());
                _qrScannerStream = null;
            }
            const area = document.getElementById('qr-scanner-area');
            if (area) area.innerHTML = '';
        }

        // --- New Session Server Selector ---
        function updateServerSelectorVisibility() {
            const row = document.getElementById('server-selector-row');
            const sel = document.getElementById('new-session-server');
            if (_isMultiServer()) {
                row.style.display = 'block';
                sel.innerHTML = servers.filter(s => s.enabled).map(s =>
                    `<option value="${escHtml(s.key)}">${escHtml(s.label)}</option>`
                ).join('');
                sel.value = _newSessionServer;
            } else {
                row.style.display = 'none';
                _newSessionServer = 'local';
            }
        }

        function onNewSessionServerChange() {
            const sel = document.getElementById('new-session-server');
            _newSessionServer = sel.value;
            // Load config from selected server
            const cached = _serverConfigs[_newSessionServer];
            if (cached) {
                allowedCommands = cached.allowed_commands || [];
                populateCommandSelect();
                browseTo('~', _newSessionServer);
            } else {
                fetchConfig(_newSessionServer);
            }
        }

        const _SAFE_NAME_RE = /^[a-zA-Z0-9][a-zA-Z0-9 _.~-]{0,63}$/;

        function validateNewSession() {
            const name = document.getElementById('new-name').value.trim();
            const nameInput = document.getElementById('new-name');
            const nameError = document.getElementById('name-error');
            const btn = document.getElementById('run-btn');
            // Check name against sessions on the target server
            const serverSessions = sessions.filter(s => s._server === _newSessionServer);
            const nameTaken = name && serverSessions.some(s => s.name === name);
            const nameInvalid = name && !_SAFE_NAME_RE.test(name);
            nameError.textContent = nameTaken ? 'Name already taken' : nameInvalid ? 'Only letters, numbers, hyphens, underscores' : '';
            nameError.style.display = (nameTaken || nameInvalid) ? 'block' : 'none';
            nameInput.style.borderColor = (nameTaken || nameInvalid) ? '#ff6666' : '#2a2a5a';
            btn.disabled = !name || nameTaken || nameInvalid || !selectedCwd;
        }

        function toggleNewSession() {
            const dialog = document.getElementById('new-session-dialog');
            dialog.classList.toggle('open');
            if (dialog.classList.contains('open')) {
                updateServerSelectorVisibility();
                document.getElementById('new-name').focus();
                validateNewSession();
            }
        }

        async function createSession() {
            const name = document.getElementById('new-name').value.trim();
            const command = document.getElementById('new-command').value;
            const cwd = selectedCwd || null;
            if (!name || !command) return;

            try {
                const resp = await fetch(serverUrl(_newSessionServer, '/sessions/run'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, command, cwd }),
                });
                if (resp.ok) {
                    document.getElementById('new-name').value = '';
                    document.getElementById('new-session-dialog').classList.remove('open');
                    await fetchAllSessions();
                    const cid = compoundId(_newSessionServer, name);
                    openSession(cid, name);
                } else {
                    const err = await resp.json();
                    alert(err.detail || 'Failed to create session');
                }
            } catch (e) {
                alert('Server unreachable');
            }
        }

        function showConfirm(message) {
            return new Promise(resolve => {
                const overlay = document.getElementById('confirm-dialog');
                document.getElementById('confirm-msg').textContent = message;
                overlay.classList.add('open');
                const yes = document.getElementById('confirm-yes');
                const no = document.getElementById('confirm-no');
                function cleanup(result) {
                    overlay.classList.remove('open');
                    yes.replaceWith(yes.cloneNode(true));
                    no.replaceWith(no.cloneNode(true));
                    resolve(result);
                }
                yes.addEventListener('click', () => cleanup(true), { once: true });
                no.addEventListener('click', () => cleanup(false), { once: true });
                overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(false); }, { once: true });
            });
        }

        async function killSession(cid) {
            const { server, sessionId } = parseCompoundId(cid);
            const session = sessions.find(s => s._compoundId === cid);
            const label = session ? session.name : 'this session';
            if (!await showConfirm(`Stop "${label}"? This will terminate the process.`)) return;
            try {
                await fetch(serverUrl(server, `/sessions/${sessionId}`), { method: 'DELETE' });
                closePanel(cid);
                await fetchAllSessions();
            } catch (e) {}
        }

        async function resumeSession(cid) {
            const { server, sessionId } = parseCompoundId(cid);
            try {
                const resp = await fetch(serverUrl(server, `/sessions/${sessionId}/resume`), { method: 'POST' });
                if (resp.ok) {
                    await fetchAllSessions();
                    openSession(cid, sessionId);
                } else {
                    const err = await resp.json();
                    alert(err.detail || 'Failed to resume session');
                }
            } catch (e) {
                alert('Server unreachable');
            }
        }

        async function dismissSession(cid) {
            const { server, sessionId } = parseCompoundId(cid);
            const session = sessions.find(s => s._compoundId === cid);
            const label = session ? session.name : 'this session';
            if (!await showConfirm(`Dismiss "${label}"? The resume token will be lost.`)) return;
            try {
                await fetch(serverUrl(server, `/sessions/${sessionId}`), { method: 'DELETE' });
                await fetchAllSessions();
            } catch (e) {}
        }

        // --- Window resize fallback ---
        window.addEventListener('resize', debounce(() => {
            panels.forEach(p => fitPanel(p));
        }, 150));

        // --- Notifications ---
        // Detect when a session needs attention by scanning terminal output.
        // Two triggers: (1) permission/question prompts, (2) long idle after sustained activity.
        let notificationsEnabled = false;

        async function requestNotificationPermission() {
            if (!('Notification' in window)) return false;
            if (Notification.permission === 'granted') return true;
            if (Notification.permission === 'denied') return false;
            const result = await Notification.requestPermission();
            return result === 'granted';
        }

        function sendNotification(title, body) {
            if (!notificationsEnabled) return;
            if (document.visibilityState === 'visible') return;
            try {
                new Notification(title, {
                    body: body,
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="80" font-size="80">♭</text></svg>',
                    tag: 'conductor-' + title,
                });
            } catch (e) {}
        }

        // Read the last N non-empty lines from the xterm buffer
        function getTerminalTail(panel, count) {
            if (!panel.terminal) return '';
            const buf = panel.terminal.buffer.active;
            const lines = [];
            for (let i = buf.length - 1; i >= 0 && lines.length < count; i--) {
                const line = buf.getLine(i);
                if (line) {
                    const text = line.translateToString(true).trim();
                    if (text) lines.unshift(text);
                }
            }
            return lines.join('\n');
        }

        const _activityTimers = {};
        const _outputBytes = {};     // track output volume per panel
        const _lastNotified = {};    // prevent duplicate notifications
        function trackActivity(panel) {
            if (_activityTimers[panel.id]) clearTimeout(_activityTimers[panel.id]);

            // Count output chunks — we only notify after sustained activity
            _outputBytes[panel.id] = (_outputBytes[panel.id] || 0) + 1;

            _activityTimers[panel.id] = setTimeout(() => {
                // Need real output before we consider notifying
                const volume = _outputBytes[panel.id] || 0;
                _outputBytes[panel.id] = 0;
                if (volume < 10) return; // ignore tiny bursts (keepalives, cursor moves)

                const tail = getTerminalTail(panel, 8);
                if (!tail) return;

                let reason = null;
                // Permission / confirmation prompts
                if (/\(y\)es.*\(n\)o/i.test(tail) || /\[Y\/n\]/i.test(tail) || /\(y\/n\)/i.test(tail)) {
                    reason = 'Needs confirmation';
                } else if (/allow|deny|approve|reject/i.test(tail) && /\?/m.test(tail)) {
                    reason = 'Asking for permission';
                // Question being asked
                } else if (/\?\s*$/m.test(tail)) {
                    reason = 'Asking a question';
                // Long idle after lots of output = task likely finished
                } else if (volume > 100) {
                    reason = 'Task may be complete';
                }

                if (!reason) return;
                // Don't re-notify the same thing
                const key = panel.id + ':' + reason;
                if (_lastNotified[key]) return;
                _lastNotified[key] = true;
                // Clear after 60s so we can notify again for a new occurrence
                setTimeout(() => { delete _lastNotified[key]; }, 60000);

                sendNotification(`♭ ${panel.name}`, reason);
            }, 5000); // 5s of silence before checking
        }

        // --- Init ---
        // Load server registry from localStorage
        loadServers();

        // On mobile, open the sidebar drawer on load
        if (window.innerWidth <= 700) {
            document.getElementById('sidebar').classList.add('open');
        }

        // Request notification permission on first user interaction
        document.addEventListener('click', async function initNotif() {
            notificationsEnabled = await requestNotificationPermission();
            document.removeEventListener('click', initNotif);
        }, { once: true });

        document.getElementById('new-name').addEventListener('input', validateNewSession);

        // Fetch local server info (hostname) and config for all enabled servers
        fetchSelfInfo();
        servers.filter(s => s.enabled).forEach(s => fetchConfig(s.key));

        // Start polling sessions from all servers
        fetchAllSessions();
        setInterval(fetchAllSessions, 3000);
    </script>
</body>
</html>
